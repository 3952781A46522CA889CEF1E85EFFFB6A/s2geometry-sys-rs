/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type std_string = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Char_alloc_type = u8;
pub type std_basic_string__Alloc_traits = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string___const_iterator = u8;
pub type std_basic_string___sv_type = u8;
pub type std_basic_string__If_sv = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _address: u8,
}
pub const std_basic_string__S_local_capacity: i32 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u64,
}
pub type std_true_type = u8;
pub type std_conditional_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category = u8;
pub type std_iterator_value_type = u8;
pub type std_iterator_difference_type = u8;
pub type std_iterator_pointer = u8;
pub type std_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_value_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u64;
pub type std_array_difference_type = u64;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
pub type std_array__AT_Type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__TC2 {
    pub _address: u8,
}
pub type std_tuple__TCC = u8;
pub type std_tuple__TMC = u8;
pub type std_tuple__TMCT = u8;
pub type std_tuple__TNTC = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unordered_map {
    pub _address: u8,
}
pub type std_unordered_map__Hashtable = u8;
pub type std_unordered_map_key_type = u8;
pub type std_unordered_map_value_type = u8;
pub type std_unordered_map_mapped_type = u8;
pub type std_unordered_map_hasher = u8;
pub type std_unordered_map_key_equal = u8;
pub type std_unordered_map_allocator_type = u8;
pub type std_unordered_map_pointer = u8;
pub type std_unordered_map_const_pointer = u8;
pub type std_unordered_map_reference = u8;
pub type std_unordered_map_const_reference = u8;
pub type std_unordered_map_iterator = u8;
pub type std_unordered_map_const_iterator = u8;
pub type std_unordered_map_local_iterator = u8;
pub type std_unordered_map_const_local_iterator = u8;
pub type std_unordered_map_size_type = u8;
pub type std_unordered_map_difference_type = u8;
pub type std_unordered_map_node_type = u8;
pub type std_unordered_map_insert_return_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_priority_queue {
    pub _address: u8,
}
pub type std_priority_queue__Uses = u8;
pub type std_priority_queue_value_type = u8;
pub type std_priority_queue_reference = u8;
pub type std_priority_queue_const_reference = u8;
pub type std_priority_queue_size_type = u8;
pub type std_priority_queue_container_type = u8;
pub type std_priority_queue_value_compare = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = u8;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
pub type absl_make_index_sequence = u8;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct absl_uint128 {
    pub _bindgen_opaque_blob: u128,
}
extern "C" {
    #[link_name = "\u{1}_ZN4absl7uint128C1Ef"]
    pub fn absl_uint128_uint128(this: *mut absl_uint128, v: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4absl7uint128C1Ed"]
    pub fn absl_uint128_uint1281(this: *mut absl_uint128, v: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4absl7uint128C1Ee"]
    pub fn absl_uint128_uint1282(this: *mut absl_uint128, v: u128);
}
impl absl_uint128 {
    #[inline]
    pub unsafe fn new(v: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        absl_uint128_uint128(__bindgen_tmp.as_mut_ptr(), v);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(v: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        absl_uint128_uint1281(__bindgen_tmp.as_mut_ptr(), v);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(v: u128) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        absl_uint128_uint1282(__bindgen_tmp.as_mut_ptr(), v);
        __bindgen_tmp.assume_init()
    }
}
pub type absl_string_view = [u64; 2usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct absl_btree_multimap {
    pub _address: u8,
}
pub type absl_btree_multimap_Base = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct absl_hash_internal_Hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct absl_btree_set {
    pub _address: u8,
}
pub type absl_btree_set_Base = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct absl_flat_hash_set {
    pub _address: u8,
}
pub type absl_flat_hash_set_Base = u8;
pub type int8 = ::std::os::raw::c_schar;
pub type int32 = ::std::os::raw::c_int;
pub type int64 = ::std::os::raw::c_longlong;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type uint64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug)]
pub struct Encoder {
    pub buf_: *mut ::std::os::raw::c_uchar,
    pub limit_: *mut ::std::os::raw::c_uchar,
    pub underlying_buffer_: *mut ::std::os::raw::c_uchar,
    pub orig_: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug)]
pub struct Encoder_Writer {
    pub enc: *mut Encoder,
    pub p: *mut ::std::os::raw::c_char,
}
pub const Encoder_kVarintMax32: ::std::os::raw::c_int = 5;
pub const Encoder_kVarintMax64: ::std::os::raw::c_int = 10;
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder5resetEv"]
    pub fn Encoder_reset(this: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder5resetEPvm"]
    pub fn Encoder_reset1(this: *mut Encoder, buf: *mut ::std::os::raw::c_void, maxn: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder5clearEv"]
    pub fn Encoder_clear(this: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder15varint32_lengthEj"]
    pub fn Encoder_varint32_length(v: uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder15varint64_lengthEy"]
    pub fn Encoder_varint64_length(v: uint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder25put_varint64_from_decoderEP7Decoder"]
    pub fn Encoder_put_varint64_from_decoder(this: *mut Encoder, dec: *mut Decoder) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7Encoder6lengthEv"]
    pub fn Encoder_length(this: *const Encoder) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7Encoder5availEv"]
    pub fn Encoder_avail(this: *const Encoder) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder6EnsureEm"]
    pub fn Encoder_Ensure(this: *mut Encoder, N: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Encoder6ResizeEm"]
    pub fn Encoder_Resize(this: *mut Encoder, N: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN7EncoderC1EOS_"]
    pub fn Encoder_Encoder(this: *mut Encoder, other: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN7EncoderC1EPvm"]
    pub fn Encoder_Encoder1(this: *mut Encoder, buf: *mut ::std::os::raw::c_void, maxn: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN7EncoderD1Ev"]
    pub fn Encoder_Encoder_destructor(this: *mut Encoder);
}
impl Encoder {
    #[inline]
    pub unsafe fn reset(&mut self) {
        Encoder_reset(self)
    }
    #[inline]
    pub unsafe fn reset1(&mut self, buf: *mut ::std::os::raw::c_void, maxn: usize) {
        Encoder_reset1(self, buf, maxn)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        Encoder_clear(self)
    }
    #[inline]
    pub unsafe fn varint32_length(v: uint32) -> ::std::os::raw::c_int {
        Encoder_varint32_length(v)
    }
    #[inline]
    pub unsafe fn varint64_length(v: uint64) -> ::std::os::raw::c_int {
        Encoder_varint64_length(v)
    }
    #[inline]
    pub unsafe fn put_varint64_from_decoder(&mut self, dec: *mut Decoder) -> bool {
        Encoder_put_varint64_from_decoder(self, dec)
    }
    #[inline]
    pub unsafe fn length(&self) -> usize {
        Encoder_length(self)
    }
    #[inline]
    pub unsafe fn avail(&self) -> usize {
        Encoder_avail(self)
    }
    #[inline]
    pub unsafe fn Ensure(&mut self, N: usize) {
        Encoder_Ensure(self, N)
    }
    #[inline]
    pub unsafe fn Resize(&mut self, N: usize) {
        Encoder_Resize(self, N)
    }
    #[inline]
    pub unsafe fn new(other: *mut Encoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Encoder_Encoder(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(buf: *mut ::std::os::raw::c_void, maxn: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Encoder_Encoder1(__bindgen_tmp.as_mut_ptr(), buf, maxn);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Encoder_Encoder_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Decoder {
    pub orig_: *const ::std::os::raw::c_uchar,
    pub buf_: *const ::std::os::raw::c_uchar,
    pub limit_: *const ::std::os::raw::c_uchar,
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder5resetEPKvm"]
    pub fn Decoder_reset(this: *mut Decoder, buf: *const ::std::os::raw::c_void, maxn: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder4get8Ev"]
    pub fn Decoder_get8(this: *mut Decoder) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder5get16Ev"]
    pub fn Decoder_get16(this: *mut Decoder) -> uint16;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder5get32Ev"]
    pub fn Decoder_get32(this: *mut Decoder) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder5get64Ev"]
    pub fn Decoder_get64(this: *mut Decoder) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder6get128Ev"]
    pub fn Decoder_get128(this: *mut Decoder) -> absl_uint128;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder8getfloatEv"]
    pub fn Decoder_getfloat(this: *mut Decoder) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder9getdoubleEv"]
    pub fn Decoder_getdouble(this: *mut Decoder) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder4getnEPvm"]
    pub fn Decoder_getn(this: *mut Decoder, mem: *mut ::std::os::raw::c_void, n: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder5getcnEPvim"]
    pub fn Decoder_getcn(
        this: *mut Decoder,
        mem: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder4getsEPvm"]
    pub fn Decoder_gets(this: *mut Decoder, mem: *mut ::std::os::raw::c_void, n: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder4skipEl"]
    pub fn Decoder_skip(this: *mut Decoder, n: isize) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7Decoder3ptrEv"]
    pub fn Decoder_ptr(this: *const Decoder) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder12get_varint32EPj"]
    pub fn Decoder_get_varint32(this: *mut Decoder, v: *mut uint32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Decoder12get_varint64EPy"]
    pub fn Decoder_get_varint64(this: *mut Decoder, v: *mut uint64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7Decoder3posEv"]
    pub fn Decoder_pos(this: *const Decoder) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7Decoder5availEv"]
    pub fn Decoder_avail(this: *const Decoder) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN7DecoderC1EPKvm"]
    pub fn Decoder_Decoder(this: *mut Decoder, buf: *const ::std::os::raw::c_void, maxn: usize);
}
impl Decoder {
    #[inline]
    pub unsafe fn reset(&mut self, buf: *const ::std::os::raw::c_void, maxn: usize) {
        Decoder_reset(self, buf, maxn)
    }
    #[inline]
    pub unsafe fn get8(&mut self) -> ::std::os::raw::c_uchar {
        Decoder_get8(self)
    }
    #[inline]
    pub unsafe fn get16(&mut self) -> uint16 {
        Decoder_get16(self)
    }
    #[inline]
    pub unsafe fn get32(&mut self) -> uint32 {
        Decoder_get32(self)
    }
    #[inline]
    pub unsafe fn get64(&mut self) -> uint64 {
        Decoder_get64(self)
    }
    #[inline]
    pub unsafe fn get128(&mut self) -> absl_uint128 {
        Decoder_get128(self)
    }
    #[inline]
    pub unsafe fn getfloat(&mut self) -> f32 {
        Decoder_getfloat(self)
    }
    #[inline]
    pub unsafe fn getdouble(&mut self) -> f64 {
        Decoder_getdouble(self)
    }
    #[inline]
    pub unsafe fn getn(&mut self, mem: *mut ::std::os::raw::c_void, n: usize) {
        Decoder_getn(self, mem, n)
    }
    #[inline]
    pub unsafe fn getcn(
        &mut self,
        mem: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: usize,
    ) {
        Decoder_getcn(self, mem, c, n)
    }
    #[inline]
    pub unsafe fn gets(&mut self, mem: *mut ::std::os::raw::c_void, n: usize) {
        Decoder_gets(self, mem, n)
    }
    #[inline]
    pub unsafe fn skip(&mut self, n: isize) -> *const ::std::os::raw::c_char {
        Decoder_skip(self, n)
    }
    #[inline]
    pub unsafe fn ptr(&self) -> *const ::std::os::raw::c_uchar {
        Decoder_ptr(self)
    }
    #[inline]
    pub unsafe fn get_varint32(&mut self, v: *mut uint32) -> bool {
        Decoder_get_varint32(self, v)
    }
    #[inline]
    pub unsafe fn get_varint64(&mut self, v: *mut uint64) -> bool {
        Decoder_get_varint64(self, v)
    }
    #[inline]
    pub unsafe fn pos(&self) -> usize {
        Decoder_pos(self)
    }
    #[inline]
    pub unsafe fn avail(&self) -> usize {
        Decoder_avail(self)
    }
    #[inline]
    pub unsafe fn new(buf: *const ::std::os::raw::c_void, maxn: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Decoder_Decoder(__bindgen_tmp.as_mut_ptr(), buf, maxn);
        __bindgen_tmp.assume_init()
    }
}
pub type util_math_internal_vector_BasicVector_D = u8;
pub type util_math_internal_vector_BasicVector_FloatType = u8;
pub type util_math_internal_vector_BasicVector_IdxSeqN = absl_make_index_sequence;
pub const util_math_internal_vector_BasicVector_SIZE: i32 = 0;
pub type util_math_internal_vector_BasicVector__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector2<T> {
    pub c_: *mut Vector2_VType<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type Vector2_Base = u8;
pub type Vector2_VType<T> = T;
pub type Vector2_BaseType<T> = Vector2_VType<T>;
pub type Vector2_FloatType = Vector2_Base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector3<T> {
    pub c_: *mut Vector3_VType<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type Vector3_Base = u8;
pub type Vector3_VType<T> = T;
pub type Vector3_BaseType<T> = Vector3_VType<T>;
pub type Vector3_FloatType = Vector3_Base;
pub type Vector2_d = Vector2<f64>;
pub type Vector3_d = Vector3<f64>;
pub type R2Point = Vector2_d;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct R1Interval {
    pub bounds_: Vector2_d,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct R2Rect {
    pub bounds_: [R1Interval; 2usize],
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2Rect5EmptyEv"]
    pub fn R2Rect_Empty() -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2Rect14FromCenterSizeERK7Vector2IdES3_"]
    pub fn R2Rect_FromCenterSize(center: *const R2Point, size: *const R2Point) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2Rect9FromPointERK7Vector2IdE"]
    pub fn R2Rect_FromPoint(p: *const R2Point) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2Rect13FromPointPairERK7Vector2IdES3_"]
    pub fn R2Rect_FromPointPair(p1: *const R2Point, p2: *const R2Point) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect8is_validEv"]
    pub fn R2Rect_is_valid(this: *const R2Rect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect8is_emptyEv"]
    pub fn R2Rect_is_empty(this: *const R2Rect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect9GetVertexEi"]
    pub fn R2Rect_GetVertex(this: *const R2Rect, k: ::std::os::raw::c_int) -> R2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect9GetVertexEii"]
    pub fn R2Rect_GetVertex1(
        this: *const R2Rect,
        i: ::std::os::raw::c_int,
        j: ::std::os::raw::c_int,
    ) -> R2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect9GetCenterEv"]
    pub fn R2Rect_GetCenter(this: *const R2Rect) -> R2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect7GetSizeEv"]
    pub fn R2Rect_GetSize(this: *const R2Rect) -> R2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect8ContainsERK7Vector2IdE"]
    pub fn R2Rect_Contains(this: *const R2Rect, p: *const R2Point) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect16InteriorContainsERK7Vector2IdE"]
    pub fn R2Rect_InteriorContains(this: *const R2Rect, p: *const R2Point) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect8ContainsERKS_"]
    pub fn R2Rect_Contains1(this: *const R2Rect, other: *const R2Rect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect16InteriorContainsERKS_"]
    pub fn R2Rect_InteriorContains1(this: *const R2Rect, other: *const R2Rect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect10IntersectsERKS_"]
    pub fn R2Rect_Intersects(this: *const R2Rect, other: *const R2Rect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect18InteriorIntersectsERKS_"]
    pub fn R2Rect_InteriorIntersects(this: *const R2Rect, other: *const R2Rect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2Rect8AddPointERK7Vector2IdE"]
    pub fn R2Rect_AddPoint(this: *mut R2Rect, p: *const R2Point);
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2Rect7AddRectERKS_"]
    pub fn R2Rect_AddRect(this: *mut R2Rect, other: *const R2Rect);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect7ProjectERK7Vector2IdE"]
    pub fn R2Rect_Project(this: *const R2Rect, p: *const R2Point) -> R2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect8ExpandedERK7Vector2IdE"]
    pub fn R2Rect_Expanded(this: *const R2Rect, margin: *const R2Point) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect8ExpandedEd"]
    pub fn R2Rect_Expanded1(this: *const R2Rect, margin: f64) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect5UnionERKS_"]
    pub fn R2Rect_Union(this: *const R2Rect, other: *const R2Rect) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect12IntersectionERKS_"]
    pub fn R2Rect_Intersection(this: *const R2Rect, other: *const R2Rect) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6R2Rect12ApproxEqualsERKS_d"]
    pub fn R2Rect_ApproxEquals(this: *const R2Rect, other: *const R2Rect, max_error: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2RectC1ERK7Vector2IdES3_"]
    pub fn R2Rect_R2Rect(this: *mut R2Rect, lo: *const R2Point, hi: *const R2Point);
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2RectC1ERK10R1IntervalS2_"]
    pub fn R2Rect_R2Rect1(this: *mut R2Rect, x: *const R1Interval, y: *const R1Interval);
}
extern "C" {
    #[link_name = "\u{1}_ZN6R2RectC1Ev"]
    pub fn R2Rect_R2Rect2(this: *mut R2Rect);
}
impl R2Rect {
    #[inline]
    pub unsafe fn Empty() -> R2Rect {
        R2Rect_Empty()
    }
    #[inline]
    pub unsafe fn FromCenterSize(center: *const R2Point, size: *const R2Point) -> R2Rect {
        R2Rect_FromCenterSize(center, size)
    }
    #[inline]
    pub unsafe fn FromPoint(p: *const R2Point) -> R2Rect {
        R2Rect_FromPoint(p)
    }
    #[inline]
    pub unsafe fn FromPointPair(p1: *const R2Point, p2: *const R2Point) -> R2Rect {
        R2Rect_FromPointPair(p1, p2)
    }
    #[inline]
    pub unsafe fn is_valid(&self) -> bool {
        R2Rect_is_valid(self)
    }
    #[inline]
    pub unsafe fn is_empty(&self) -> bool {
        R2Rect_is_empty(self)
    }
    #[inline]
    pub unsafe fn GetVertex(&self, k: ::std::os::raw::c_int) -> R2Point {
        R2Rect_GetVertex(self, k)
    }
    #[inline]
    pub unsafe fn GetVertex1(&self, i: ::std::os::raw::c_int, j: ::std::os::raw::c_int) -> R2Point {
        R2Rect_GetVertex1(self, i, j)
    }
    #[inline]
    pub unsafe fn GetCenter(&self) -> R2Point {
        R2Rect_GetCenter(self)
    }
    #[inline]
    pub unsafe fn GetSize(&self) -> R2Point {
        R2Rect_GetSize(self)
    }
    #[inline]
    pub unsafe fn Contains(&self, p: *const R2Point) -> bool {
        R2Rect_Contains(self, p)
    }
    #[inline]
    pub unsafe fn InteriorContains(&self, p: *const R2Point) -> bool {
        R2Rect_InteriorContains(self, p)
    }
    #[inline]
    pub unsafe fn Contains1(&self, other: *const R2Rect) -> bool {
        R2Rect_Contains1(self, other)
    }
    #[inline]
    pub unsafe fn InteriorContains1(&self, other: *const R2Rect) -> bool {
        R2Rect_InteriorContains1(self, other)
    }
    #[inline]
    pub unsafe fn Intersects(&self, other: *const R2Rect) -> bool {
        R2Rect_Intersects(self, other)
    }
    #[inline]
    pub unsafe fn InteriorIntersects(&self, other: *const R2Rect) -> bool {
        R2Rect_InteriorIntersects(self, other)
    }
    #[inline]
    pub unsafe fn AddPoint(&mut self, p: *const R2Point) {
        R2Rect_AddPoint(self, p)
    }
    #[inline]
    pub unsafe fn AddRect(&mut self, other: *const R2Rect) {
        R2Rect_AddRect(self, other)
    }
    #[inline]
    pub unsafe fn Project(&self, p: *const R2Point) -> R2Point {
        R2Rect_Project(self, p)
    }
    #[inline]
    pub unsafe fn Expanded(&self, margin: *const R2Point) -> R2Rect {
        R2Rect_Expanded(self, margin)
    }
    #[inline]
    pub unsafe fn Expanded1(&self, margin: f64) -> R2Rect {
        R2Rect_Expanded1(self, margin)
    }
    #[inline]
    pub unsafe fn Union(&self, other: *const R2Rect) -> R2Rect {
        R2Rect_Union(self, other)
    }
    #[inline]
    pub unsafe fn Intersection(&self, other: *const R2Rect) -> R2Rect {
        R2Rect_Intersection(self, other)
    }
    #[inline]
    pub unsafe fn ApproxEquals(&self, other: *const R2Rect, max_error: f64) -> bool {
        R2Rect_ApproxEquals(self, other, max_error)
    }
    #[inline]
    pub unsafe fn new(lo: *const R2Point, hi: *const R2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        R2Rect_R2Rect(__bindgen_tmp.as_mut_ptr(), lo, hi);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(x: *const R1Interval, y: *const R1Interval) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        R2Rect_R2Rect1(__bindgen_tmp.as_mut_ptr(), x, y);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        R2Rect_R2Rect2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub type S2Point = Vector3_d;
pub type S2PointHash = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S1Angle {
    pub radians_: f64,
}
pub type S1Angle_absl_btree_prefer_linear_node_search = std_true_type;
extern "C" {
    #[link_name = "\u{1}_ZNK7S1Angle2e5Ev"]
    pub fn S1Angle_e5(this: *const S1Angle) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7S1Angle2e6Ev"]
    pub fn S1Angle_e6(this: *const S1Angle) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7S1Angle2e7Ev"]
    pub fn S1Angle_e7(this: *const S1Angle) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7S1Angle3absEv"]
    pub fn S1Angle_abs(this: *const S1Angle) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7S1Angle10NormalizedEv"]
    pub fn S1Angle_Normalized(this: *const S1Angle) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZN7S1Angle9NormalizeEv"]
    pub fn S1Angle_Normalize(this: *mut S1Angle);
}
extern "C" {
    #[link_name = "\u{1}_ZN7S1AngleC1ERK7Vector3IdES3_"]
    pub fn S1Angle_S1Angle(this: *mut S1Angle, x: *const S2Point, y: *const S2Point);
}
extern "C" {
    #[link_name = "\u{1}_ZN7S1AngleC1ERK8S2LatLngS2_"]
    pub fn S1Angle_S1Angle1(this: *mut S1Angle, x: *const S2LatLng, y: *const S2LatLng);
}
impl S1Angle {
    #[inline]
    pub unsafe fn e5(&self) -> int32 {
        S1Angle_e5(self)
    }
    #[inline]
    pub unsafe fn e6(&self) -> int32 {
        S1Angle_e6(self)
    }
    #[inline]
    pub unsafe fn e7(&self) -> int32 {
        S1Angle_e7(self)
    }
    #[inline]
    pub unsafe fn abs(&self) -> S1Angle {
        S1Angle_abs(self)
    }
    #[inline]
    pub unsafe fn Normalized(&self) -> S1Angle {
        S1Angle_Normalized(self)
    }
    #[inline]
    pub unsafe fn Normalize(&mut self) {
        S1Angle_Normalize(self)
    }
    #[inline]
    pub unsafe fn new(x: *const S2Point, y: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S1Angle_S1Angle(__bindgen_tmp.as_mut_ptr(), x, y);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(x: *const S2LatLng, y: *const S2LatLng) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S1Angle_S1Angle1(__bindgen_tmp.as_mut_ptr(), x, y);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct S2CellId {
    pub id_: uint64,
}
pub type S2CellId_absl_btree_prefer_linear_node_search = std_true_type;
pub const S2CellId_kFaceBits: ::std::os::raw::c_int = 3;
pub const S2CellId_kNumFaces: ::std::os::raw::c_int = 6;
pub const S2CellId_kMaxLevel: ::std::os::raw::c_int = 30;
pub const S2CellId_kPosBits: ::std::os::raw::c_int = 61;
pub const S2CellId_kMaxSize: ::std::os::raw::c_int = 1073741824;
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId11kWrapOffsetE"]
    pub static S2CellId_kWrapOffset: uint64;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId8FromFaceEi"]
    pub fn S2CellId_FromFace(face: ::std::os::raw::c_int) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId16FromFacePosLevelEiyi"]
    pub fn S2CellId_FromFacePosLevel(
        face: ::std::os::raw::c_int,
        pos: uint64,
        level: ::std::os::raw::c_int,
    ) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId10ToPointRawEv"]
    pub fn S2CellId_ToPointRaw(this: *const S2CellId) -> S2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId11GetCenterSTEv"]
    pub fn S2CellId_GetCenterST(this: *const S2CellId) -> R2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9GetSizeSTEv"]
    pub fn S2CellId_GetSizeST(this: *const S2CellId) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId9GetSizeSTEi"]
    pub fn S2CellId_GetSizeST1(level: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId10GetBoundSTEv"]
    pub fn S2CellId_GetBoundST(this: *const S2CellId) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId11GetCenterUVEv"]
    pub fn S2CellId_GetCenterUV(this: *const S2CellId) -> R2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId10GetBoundUVEv"]
    pub fn S2CellId_GetBoundUV(this: *const S2CellId) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId20ExpandedByDistanceUVERK6R2Rect7S1Angle"]
    pub fn S2CellId_ExpandedByDistanceUV(uv: *const R2Rect, distance: S1Angle) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId13GetCenterSiTiEPiS0_"]
    pub fn S2CellId_GetCenterSiTi(
        this: *const S2CellId,
        psi: *mut ::std::os::raw::c_int,
        pti: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId8ToLatLngEv"]
    pub fn S2CellId_ToLatLng(this: *const S2CellId) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId8is_validEv"]
    pub fn S2CellId_is_valid(this: *const S2CellId) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId4faceEv"]
    pub fn S2CellId_face(this: *const S2CellId) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId3posEv"]
    pub fn S2CellId_pos(this: *const S2CellId) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId5levelEv"]
    pub fn S2CellId_level(this: *const S2CellId) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9GetSizeIJEv"]
    pub fn S2CellId_GetSizeIJ(this: *const S2CellId) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId9GetSizeIJEi"]
    pub fn S2CellId_GetSizeIJ1(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId7is_leafEv"]
    pub fn S2CellId_is_leaf(this: *const S2CellId) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId7is_faceEv"]
    pub fn S2CellId_is_face(this: *const S2CellId) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId14child_positionEv"]
    pub fn S2CellId_child_position(this: *const S2CellId) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId14child_positionEi"]
    pub fn S2CellId_child_position1(
        this: *const S2CellId,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9range_minEv"]
    pub fn S2CellId_range_min(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9range_maxEv"]
    pub fn S2CellId_range_max(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId8containsES_"]
    pub fn S2CellId_contains(this: *const S2CellId, other: S2CellId) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId10intersectsES_"]
    pub fn S2CellId_intersects(this: *const S2CellId, other: S2CellId) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId6parentEv"]
    pub fn S2CellId_parent(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId6parentEi"]
    pub fn S2CellId_parent1(this: *const S2CellId, level: ::std::os::raw::c_int) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId5childEi"]
    pub fn S2CellId_child(this: *const S2CellId, position: ::std::os::raw::c_int) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId11child_beginEv"]
    pub fn S2CellId_child_begin(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId11child_beginEi"]
    pub fn S2CellId_child_begin1(this: *const S2CellId, level: ::std::os::raw::c_int) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9child_endEv"]
    pub fn S2CellId_child_end(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9child_endEi"]
    pub fn S2CellId_child_end1(this: *const S2CellId, level: ::std::os::raw::c_int) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId4nextEv"]
    pub fn S2CellId_next(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId4prevEv"]
    pub fn S2CellId_prev(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId7advanceEx"]
    pub fn S2CellId_advance(this: *const S2CellId, steps: int64) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId19distance_from_beginEv"]
    pub fn S2CellId_distance_from_begin(this: *const S2CellId) -> int64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9next_wrapEv"]
    pub fn S2CellId_next_wrap(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId9prev_wrapEv"]
    pub fn S2CellId_prev_wrap(this: *const S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId12advance_wrapEx"]
    pub fn S2CellId_advance_wrap(this: *const S2CellId, steps: int64) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId12maximum_tileES_"]
    pub fn S2CellId_maximum_tile(this: *const S2CellId, limit: S2CellId) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId22GetCommonAncestorLevelES_"]
    pub fn S2CellId_GetCommonAncestorLevel(
        this: *const S2CellId,
        other: S2CellId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId5BeginEi"]
    pub fn S2CellId_Begin(level: ::std::os::raw::c_int) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId3EndEi"]
    pub fn S2CellId_End(level: ::std::os::raw::c_int) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId7ToTokenB5cxx11Ev"]
    pub fn S2CellId_ToToken(this: *const S2CellId) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId9FromTokenESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2CellId_FromToken(token: absl_string_view) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId6EncodeEP7Encoder"]
    pub fn S2CellId_Encode(this: *const S2CellId, encoder: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId6DecodeEP7Decoder"]
    pub fn S2CellId_Decode(this: *mut S2CellId, decoder: *mut Decoder) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId8ToStringB5cxx11Ev"]
    pub fn S2CellId_ToString(this: *const S2CellId) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId15FromDebugStringESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2CellId_FromDebugString(str_: absl_string_view) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId16GetEdgeNeighborsEPS_"]
    pub fn S2CellId_GetEdgeNeighbors(this: *const S2CellId, neighbors: *mut S2CellId);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId21AppendVertexNeighborsEiPSt6vectorIS_SaIS_EE"]
    pub fn S2CellId_AppendVertexNeighbors(
        this: *const S2CellId,
        level: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId18AppendAllNeighborsEiPSt6vectorIS_SaIS_EE"]
    pub fn S2CellId_AppendAllNeighbors(
        this: *const S2CellId,
        nbr_level: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId10FromFaceIJEiii"]
    pub fn S2CellId_FromFaceIJ(
        face: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        j: ::std::os::raw::c_int,
    ) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2CellId19ToFaceIJOrientationEPiS0_S0_"]
    pub fn S2CellId_ToFaceIJOrientation(
        this: *const S2CellId,
        pi: *mut ::std::os::raw::c_int,
        pj: *mut ::std::os::raw::c_int,
        orientation: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellId16IJLevelToBoundUVEPii"]
    pub fn S2CellId_IJLevelToBoundUV(
        ij: *mut ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    ) -> R2Rect;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellIdC1ERK7Vector3IdE"]
    pub fn S2CellId_S2CellId(this: *mut S2CellId, p: *const S2Point);
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2CellIdC1ERK8S2LatLng"]
    pub fn S2CellId_S2CellId1(this: *mut S2CellId, ll: *const S2LatLng);
}
impl S2CellId {
    #[inline]
    pub unsafe fn FromFace(face: ::std::os::raw::c_int) -> S2CellId {
        S2CellId_FromFace(face)
    }
    #[inline]
    pub unsafe fn FromFacePosLevel(
        face: ::std::os::raw::c_int,
        pos: uint64,
        level: ::std::os::raw::c_int,
    ) -> S2CellId {
        S2CellId_FromFacePosLevel(face, pos, level)
    }
    #[inline]
    pub unsafe fn ToPointRaw(&self) -> S2Point {
        S2CellId_ToPointRaw(self)
    }
    #[inline]
    pub unsafe fn GetCenterST(&self) -> R2Point {
        S2CellId_GetCenterST(self)
    }
    #[inline]
    pub unsafe fn GetSizeST(&self) -> f64 {
        S2CellId_GetSizeST(self)
    }
    #[inline]
    pub unsafe fn GetSizeST1(level: ::std::os::raw::c_int) -> f64 {
        S2CellId_GetSizeST1(level)
    }
    #[inline]
    pub unsafe fn GetBoundST(&self) -> R2Rect {
        S2CellId_GetBoundST(self)
    }
    #[inline]
    pub unsafe fn GetCenterUV(&self) -> R2Point {
        S2CellId_GetCenterUV(self)
    }
    #[inline]
    pub unsafe fn GetBoundUV(&self) -> R2Rect {
        S2CellId_GetBoundUV(self)
    }
    #[inline]
    pub unsafe fn ExpandedByDistanceUV(uv: *const R2Rect, distance: S1Angle) -> R2Rect {
        S2CellId_ExpandedByDistanceUV(uv, distance)
    }
    #[inline]
    pub unsafe fn GetCenterSiTi(
        &self,
        psi: *mut ::std::os::raw::c_int,
        pti: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        S2CellId_GetCenterSiTi(self, psi, pti)
    }
    #[inline]
    pub unsafe fn ToLatLng(&self) -> S2LatLng {
        S2CellId_ToLatLng(self)
    }
    #[inline]
    pub unsafe fn is_valid(&self) -> bool {
        S2CellId_is_valid(self)
    }
    #[inline]
    pub unsafe fn face(&self) -> ::std::os::raw::c_int {
        S2CellId_face(self)
    }
    #[inline]
    pub unsafe fn pos(&self) -> uint64 {
        S2CellId_pos(self)
    }
    #[inline]
    pub unsafe fn level(&self) -> ::std::os::raw::c_int {
        S2CellId_level(self)
    }
    #[inline]
    pub unsafe fn GetSizeIJ(&self) -> ::std::os::raw::c_int {
        S2CellId_GetSizeIJ(self)
    }
    #[inline]
    pub unsafe fn GetSizeIJ1(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        S2CellId_GetSizeIJ1(level)
    }
    #[inline]
    pub unsafe fn is_leaf(&self) -> bool {
        S2CellId_is_leaf(self)
    }
    #[inline]
    pub unsafe fn is_face(&self) -> bool {
        S2CellId_is_face(self)
    }
    #[inline]
    pub unsafe fn child_position(&self) -> ::std::os::raw::c_int {
        S2CellId_child_position(self)
    }
    #[inline]
    pub unsafe fn child_position1(&self, level: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        S2CellId_child_position1(self, level)
    }
    #[inline]
    pub unsafe fn range_min(&self) -> S2CellId {
        S2CellId_range_min(self)
    }
    #[inline]
    pub unsafe fn range_max(&self) -> S2CellId {
        S2CellId_range_max(self)
    }
    #[inline]
    pub unsafe fn contains(&self, other: S2CellId) -> bool {
        S2CellId_contains(self, other)
    }
    #[inline]
    pub unsafe fn intersects(&self, other: S2CellId) -> bool {
        S2CellId_intersects(self, other)
    }
    #[inline]
    pub unsafe fn parent(&self) -> S2CellId {
        S2CellId_parent(self)
    }
    #[inline]
    pub unsafe fn parent1(&self, level: ::std::os::raw::c_int) -> S2CellId {
        S2CellId_parent1(self, level)
    }
    #[inline]
    pub unsafe fn child(&self, position: ::std::os::raw::c_int) -> S2CellId {
        S2CellId_child(self, position)
    }
    #[inline]
    pub unsafe fn child_begin(&self) -> S2CellId {
        S2CellId_child_begin(self)
    }
    #[inline]
    pub unsafe fn child_begin1(&self, level: ::std::os::raw::c_int) -> S2CellId {
        S2CellId_child_begin1(self, level)
    }
    #[inline]
    pub unsafe fn child_end(&self) -> S2CellId {
        S2CellId_child_end(self)
    }
    #[inline]
    pub unsafe fn child_end1(&self, level: ::std::os::raw::c_int) -> S2CellId {
        S2CellId_child_end1(self, level)
    }
    #[inline]
    pub unsafe fn next(&self) -> S2CellId {
        S2CellId_next(self)
    }
    #[inline]
    pub unsafe fn prev(&self) -> S2CellId {
        S2CellId_prev(self)
    }
    #[inline]
    pub unsafe fn advance(&self, steps: int64) -> S2CellId {
        S2CellId_advance(self, steps)
    }
    #[inline]
    pub unsafe fn distance_from_begin(&self) -> int64 {
        S2CellId_distance_from_begin(self)
    }
    #[inline]
    pub unsafe fn next_wrap(&self) -> S2CellId {
        S2CellId_next_wrap(self)
    }
    #[inline]
    pub unsafe fn prev_wrap(&self) -> S2CellId {
        S2CellId_prev_wrap(self)
    }
    #[inline]
    pub unsafe fn advance_wrap(&self, steps: int64) -> S2CellId {
        S2CellId_advance_wrap(self, steps)
    }
    #[inline]
    pub unsafe fn maximum_tile(&self, limit: S2CellId) -> S2CellId {
        S2CellId_maximum_tile(self, limit)
    }
    #[inline]
    pub unsafe fn GetCommonAncestorLevel(&self, other: S2CellId) -> ::std::os::raw::c_int {
        S2CellId_GetCommonAncestorLevel(self, other)
    }
    #[inline]
    pub unsafe fn Begin(level: ::std::os::raw::c_int) -> S2CellId {
        S2CellId_Begin(level)
    }
    #[inline]
    pub unsafe fn End(level: ::std::os::raw::c_int) -> S2CellId {
        S2CellId_End(level)
    }
    #[inline]
    pub unsafe fn ToToken(&self) -> std_string {
        S2CellId_ToToken(self)
    }
    #[inline]
    pub unsafe fn FromToken(token: absl_string_view) -> S2CellId {
        S2CellId_FromToken(token)
    }
    #[inline]
    pub unsafe fn Encode(&self, encoder: *mut Encoder) {
        S2CellId_Encode(self, encoder)
    }
    #[inline]
    pub unsafe fn Decode(&mut self, decoder: *mut Decoder) -> bool {
        S2CellId_Decode(self, decoder)
    }
    #[inline]
    pub unsafe fn ToString(&self) -> std_string {
        S2CellId_ToString(self)
    }
    #[inline]
    pub unsafe fn FromDebugString(str_: absl_string_view) -> S2CellId {
        S2CellId_FromDebugString(str_)
    }
    #[inline]
    pub unsafe fn GetEdgeNeighbors(&self, neighbors: *mut S2CellId) {
        S2CellId_GetEdgeNeighbors(self, neighbors)
    }
    #[inline]
    pub unsafe fn AppendVertexNeighbors(
        &self,
        level: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    ) {
        S2CellId_AppendVertexNeighbors(self, level, output)
    }
    #[inline]
    pub unsafe fn AppendAllNeighbors(
        &self,
        nbr_level: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    ) {
        S2CellId_AppendAllNeighbors(self, nbr_level, output)
    }
    #[inline]
    pub unsafe fn FromFaceIJ(
        face: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        j: ::std::os::raw::c_int,
    ) -> S2CellId {
        S2CellId_FromFaceIJ(face, i, j)
    }
    #[inline]
    pub unsafe fn ToFaceIJOrientation(
        &self,
        pi: *mut ::std::os::raw::c_int,
        pj: *mut ::std::os::raw::c_int,
        orientation: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        S2CellId_ToFaceIJOrientation(self, pi, pj, orientation)
    }
    #[inline]
    pub unsafe fn IJLevelToBoundUV(
        ij: *mut ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    ) -> R2Rect {
        S2CellId_IJLevelToBoundUV(ij, level)
    }
    #[inline]
    pub unsafe fn new(p: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellId_S2CellId(__bindgen_tmp.as_mut_ptr(), p);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(ll: *const S2LatLng) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellId_S2CellId1(__bindgen_tmp.as_mut_ptr(), ll);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2internal_BTreeMultimap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2PointIndex {
    pub map_: S2PointIndex_Map,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2PointIndex_PointData {
    pub tuple_: u8,
}
pub type S2PointIndex_Map = s2internal_BTreeMultimap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2PointIndex_Iterator {
    pub map_: *const S2PointIndex_Map,
    pub iter_: S2PointIndex_Map,
    pub end_: S2PointIndex_Map,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2LatLng {
    pub coords_: R2Point,
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng7InvalidEv"]
    pub fn S2LatLng_Invalid() -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng11FromRadiansEdd"]
    pub fn S2LatLng_FromRadians(lat_radians: f64, lng_radians: f64) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng11FromDegreesEdd"]
    pub fn S2LatLng_FromDegrees(lat_degrees: f64, lng_degrees: f64) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng6FromE5Eii"]
    pub fn S2LatLng_FromE5(lat_e5: int32, lng_e5: int32) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng6FromE6Eii"]
    pub fn S2LatLng_FromE6(lat_e6: int32, lng_e6: int32) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng6FromE7Eii"]
    pub fn S2LatLng_FromE7(lat_e7: int32, lng_e7: int32) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng14FromUnsignedE6Ejj"]
    pub fn S2LatLng_FromUnsignedE6(lat_e6: uint32, lng_e6: uint32) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng14FromUnsignedE7Ejj"]
    pub fn S2LatLng_FromUnsignedE7(lat_e7: uint32, lng_e7: uint32) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng8LatitudeERK7Vector3IdE"]
    pub fn S2LatLng_Latitude(p: *const S2Point) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLng9LongitudeERK7Vector3IdE"]
    pub fn S2LatLng_Longitude(p: *const S2Point) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2LatLng8is_validEv"]
    pub fn S2LatLng_is_valid(this: *const S2LatLng) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2LatLng10NormalizedEv"]
    pub fn S2LatLng_Normalized(this: *const S2LatLng) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2LatLng7ToPointEv"]
    pub fn S2LatLng_ToPoint(this: *const S2LatLng) -> S2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2LatLng11GetDistanceERKS_"]
    pub fn S2LatLng_GetDistance(this: *const S2LatLng, o: *const S2LatLng) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2LatLng17ToStringInDegreesB5cxx11Ev"]
    pub fn S2LatLng_ToStringInDegrees(this: *const S2LatLng) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLngC1E7S1AngleS0_"]
    pub fn S2LatLng_S2LatLng(this: *mut S2LatLng, lat: S1Angle, lng: S1Angle);
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLngC1Ev"]
    pub fn S2LatLng_S2LatLng1(this: *mut S2LatLng);
}
extern "C" {
    #[link_name = "\u{1}_ZN8S2LatLngC1ERK7Vector3IdE"]
    pub fn S2LatLng_S2LatLng2(this: *mut S2LatLng, p: *const S2Point);
}
impl S2LatLng {
    #[inline]
    pub unsafe fn Invalid() -> S2LatLng {
        S2LatLng_Invalid()
    }
    #[inline]
    pub unsafe fn FromRadians(lat_radians: f64, lng_radians: f64) -> S2LatLng {
        S2LatLng_FromRadians(lat_radians, lng_radians)
    }
    #[inline]
    pub unsafe fn FromDegrees(lat_degrees: f64, lng_degrees: f64) -> S2LatLng {
        S2LatLng_FromDegrees(lat_degrees, lng_degrees)
    }
    #[inline]
    pub unsafe fn FromE5(lat_e5: int32, lng_e5: int32) -> S2LatLng {
        S2LatLng_FromE5(lat_e5, lng_e5)
    }
    #[inline]
    pub unsafe fn FromE6(lat_e6: int32, lng_e6: int32) -> S2LatLng {
        S2LatLng_FromE6(lat_e6, lng_e6)
    }
    #[inline]
    pub unsafe fn FromE7(lat_e7: int32, lng_e7: int32) -> S2LatLng {
        S2LatLng_FromE7(lat_e7, lng_e7)
    }
    #[inline]
    pub unsafe fn FromUnsignedE6(lat_e6: uint32, lng_e6: uint32) -> S2LatLng {
        S2LatLng_FromUnsignedE6(lat_e6, lng_e6)
    }
    #[inline]
    pub unsafe fn FromUnsignedE7(lat_e7: uint32, lng_e7: uint32) -> S2LatLng {
        S2LatLng_FromUnsignedE7(lat_e7, lng_e7)
    }
    #[inline]
    pub unsafe fn Latitude(p: *const S2Point) -> S1Angle {
        S2LatLng_Latitude(p)
    }
    #[inline]
    pub unsafe fn Longitude(p: *const S2Point) -> S1Angle {
        S2LatLng_Longitude(p)
    }
    #[inline]
    pub unsafe fn is_valid(&self) -> bool {
        S2LatLng_is_valid(self)
    }
    #[inline]
    pub unsafe fn Normalized(&self) -> S2LatLng {
        S2LatLng_Normalized(self)
    }
    #[inline]
    pub unsafe fn ToPoint(&self) -> S2Point {
        S2LatLng_ToPoint(self)
    }
    #[inline]
    pub unsafe fn GetDistance(&self, o: *const S2LatLng) -> S1Angle {
        S2LatLng_GetDistance(self, o)
    }
    #[inline]
    pub unsafe fn ToStringInDegrees(&self) -> std_string {
        S2LatLng_ToStringInDegrees(self)
    }
    #[inline]
    pub unsafe fn new(lat: S1Angle, lng: S1Angle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2LatLng_S2LatLng(__bindgen_tmp.as_mut_ptr(), lat, lng);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2LatLng_S2LatLng1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(p: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2LatLng_S2LatLng2(__bindgen_tmp.as_mut_ptr(), p);
        __bindgen_tmp.assume_init()
    }
}
pub type S2LatLngHash = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S1ChordAngle {
    pub length2_: f64,
}
pub type S1ChordAngle_absl_btree_prefer_linear_node_search = std_true_type;
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle4ZeroEv"]
    pub fn S1ChordAngle_Zero() -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle5RightEv"]
    pub fn S1ChordAngle_Right() -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle8StraightEv"]
    pub fn S1ChordAngle_Straight() -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle8InfinityEv"]
    pub fn S1ChordAngle_Infinity() -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle8NegativeEv"]
    pub fn S1ChordAngle_Negative() -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle7RadiansEd"]
    pub fn S1ChordAngle_Radians(radians: f64) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle7DegreesEd"]
    pub fn S1ChordAngle_Degrees(degrees: f64) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle2E5Ei"]
    pub fn S1ChordAngle_E5(e5: int32) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle2E6Ei"]
    pub fn S1ChordAngle_E6(e6: int32) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle2E7Ei"]
    pub fn S1ChordAngle_E7(e7: int32) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle18FastUpperBoundFromE7S1Angle"]
    pub fn S1ChordAngle_FastUpperBoundFrom(angle: S1Angle) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngle11FromLength2Ed"]
    pub fn S1ChordAngle_FromLength2(length2: f64) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle7ToAngleEv"]
    pub fn S1ChordAngle_ToAngle(this: *const S1ChordAngle) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle7radiansEv"]
    pub fn S1ChordAngle_radians(this: *const S1ChordAngle) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle7degreesEv"]
    pub fn S1ChordAngle_degrees(this: *const S1ChordAngle) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle2e5Ev"]
    pub fn S1ChordAngle_e5(this: *const S1ChordAngle) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle2e6Ev"]
    pub fn S1ChordAngle_e6(this: *const S1ChordAngle) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle2e7Ev"]
    pub fn S1ChordAngle_e7(this: *const S1ChordAngle) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle7is_zeroEv"]
    pub fn S1ChordAngle_is_zero(this: *const S1ChordAngle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle11is_negativeEv"]
    pub fn S1ChordAngle_is_negative(this: *const S1ChordAngle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle11is_infinityEv"]
    pub fn S1ChordAngle_is_infinity(this: *const S1ChordAngle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle10is_specialEv"]
    pub fn S1ChordAngle_is_special(this: *const S1ChordAngle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle9SuccessorEv"]
    pub fn S1ChordAngle_Successor(this: *const S1ChordAngle) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle11PredecessorEv"]
    pub fn S1ChordAngle_Predecessor(this: *const S1ChordAngle) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle9PlusErrorEd"]
    pub fn S1ChordAngle_PlusError(this: *const S1ChordAngle, error: f64) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle29GetS2PointConstructorMaxErrorEv"]
    pub fn S1ChordAngle_GetS2PointConstructorMaxError(this: *const S1ChordAngle) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle29GetS1AngleConstructorMaxErrorEv"]
    pub fn S1ChordAngle_GetS1AngleConstructorMaxError(this: *const S1ChordAngle) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S1ChordAngle8is_validEv"]
    pub fn S1ChordAngle_is_valid(this: *const S1ChordAngle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngleC1ERK7Vector3IdES3_"]
    pub fn S1ChordAngle_S1ChordAngle(this: *mut S1ChordAngle, x: *const S2Point, y: *const S2Point);
}
extern "C" {
    #[link_name = "\u{1}_ZN12S1ChordAngleC1E7S1Angle"]
    pub fn S1ChordAngle_S1ChordAngle1(this: *mut S1ChordAngle, angle: S1Angle);
}
impl S1ChordAngle {
    #[inline]
    pub unsafe fn Zero() -> S1ChordAngle {
        S1ChordAngle_Zero()
    }
    #[inline]
    pub unsafe fn Right() -> S1ChordAngle {
        S1ChordAngle_Right()
    }
    #[inline]
    pub unsafe fn Straight() -> S1ChordAngle {
        S1ChordAngle_Straight()
    }
    #[inline]
    pub unsafe fn Infinity() -> S1ChordAngle {
        S1ChordAngle_Infinity()
    }
    #[inline]
    pub unsafe fn Negative() -> S1ChordAngle {
        S1ChordAngle_Negative()
    }
    #[inline]
    pub unsafe fn Radians(radians: f64) -> S1ChordAngle {
        S1ChordAngle_Radians(radians)
    }
    #[inline]
    pub unsafe fn Degrees(degrees: f64) -> S1ChordAngle {
        S1ChordAngle_Degrees(degrees)
    }
    #[inline]
    pub unsafe fn E5(e5: int32) -> S1ChordAngle {
        S1ChordAngle_E5(e5)
    }
    #[inline]
    pub unsafe fn E6(e6: int32) -> S1ChordAngle {
        S1ChordAngle_E6(e6)
    }
    #[inline]
    pub unsafe fn E7(e7: int32) -> S1ChordAngle {
        S1ChordAngle_E7(e7)
    }
    #[inline]
    pub unsafe fn FastUpperBoundFrom(angle: S1Angle) -> S1ChordAngle {
        S1ChordAngle_FastUpperBoundFrom(angle)
    }
    #[inline]
    pub unsafe fn FromLength2(length2: f64) -> S1ChordAngle {
        S1ChordAngle_FromLength2(length2)
    }
    #[inline]
    pub unsafe fn ToAngle(&self) -> S1Angle {
        S1ChordAngle_ToAngle(self)
    }
    #[inline]
    pub unsafe fn radians(&self) -> f64 {
        S1ChordAngle_radians(self)
    }
    #[inline]
    pub unsafe fn degrees(&self) -> f64 {
        S1ChordAngle_degrees(self)
    }
    #[inline]
    pub unsafe fn e5(&self) -> int32 {
        S1ChordAngle_e5(self)
    }
    #[inline]
    pub unsafe fn e6(&self) -> int32 {
        S1ChordAngle_e6(self)
    }
    #[inline]
    pub unsafe fn e7(&self) -> int32 {
        S1ChordAngle_e7(self)
    }
    #[inline]
    pub unsafe fn is_zero(&self) -> bool {
        S1ChordAngle_is_zero(self)
    }
    #[inline]
    pub unsafe fn is_negative(&self) -> bool {
        S1ChordAngle_is_negative(self)
    }
    #[inline]
    pub unsafe fn is_infinity(&self) -> bool {
        S1ChordAngle_is_infinity(self)
    }
    #[inline]
    pub unsafe fn is_special(&self) -> bool {
        S1ChordAngle_is_special(self)
    }
    #[inline]
    pub unsafe fn Successor(&self) -> S1ChordAngle {
        S1ChordAngle_Successor(self)
    }
    #[inline]
    pub unsafe fn Predecessor(&self) -> S1ChordAngle {
        S1ChordAngle_Predecessor(self)
    }
    #[inline]
    pub unsafe fn PlusError(&self, error: f64) -> S1ChordAngle {
        S1ChordAngle_PlusError(self, error)
    }
    #[inline]
    pub unsafe fn GetS2PointConstructorMaxError(&self) -> f64 {
        S1ChordAngle_GetS2PointConstructorMaxError(self)
    }
    #[inline]
    pub unsafe fn GetS1AngleConstructorMaxError(&self) -> f64 {
        S1ChordAngle_GetS1AngleConstructorMaxError(self)
    }
    #[inline]
    pub unsafe fn is_valid(&self) -> bool {
        S1ChordAngle_is_valid(self)
    }
    #[inline]
    pub unsafe fn new(x: *const S2Point, y: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S1ChordAngle_S1ChordAngle(__bindgen_tmp.as_mut_ptr(), x, y);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(angle: S1Angle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S1ChordAngle_S1ChordAngle1(__bindgen_tmp.as_mut_ptr(), angle);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct S2Region__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct S2Region {
    pub vtable_: *const S2Region__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}_ZNK8S2Region17GetCellUnionBoundEPSt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2Region_GetCellUnionBound(
        this: *mut ::std::os::raw::c_void,
        cell_ids: *mut [u64; 3usize],
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct S2Cell {
    pub _base: S2Region,
    pub face_: int8,
    pub level_: int8,
    pub orientation_: int8,
    pub id_: S2CellId,
    pub uv_: R2Rect,
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell9GetSizeIJEv"]
    pub fn S2Cell_GetSizeIJ(this: *const S2Cell) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell9GetSizeSTEv"]
    pub fn S2Cell_GetSizeST(this: *const S2Cell) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell10GetEdgeRawEi"]
    pub fn S2Cell_GetEdgeRaw(this: *const S2Cell, k: ::std::os::raw::c_int) -> S2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell9SubdivideEPS_"]
    pub fn S2Cell_Subdivide(this: *const S2Cell, children: *mut S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell12GetCenterRawEv"]
    pub fn S2Cell_GetCenterRaw(this: *const S2Cell) -> S2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZN6S2Cell11AverageAreaEi"]
    pub fn S2Cell_AverageArea(level: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell10ApproxAreaEv"]
    pub fn S2Cell_ApproxArea(this: *const S2Cell) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell9ExactAreaEv"]
    pub fn S2Cell_ExactArea(this: *const S2Cell) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell11GetDistanceERK7Vector3IdE"]
    pub fn S2Cell_GetDistance(this: *const S2Cell, target: *const S2Point) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell19GetBoundaryDistanceERK7Vector3IdE"]
    pub fn S2Cell_GetBoundaryDistance(this: *const S2Cell, target: *const S2Point) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell14GetMaxDistanceERK7Vector3IdE"]
    pub fn S2Cell_GetMaxDistance(this: *const S2Cell, target: *const S2Point) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell11GetDistanceERK7Vector3IdES3_"]
    pub fn S2Cell_GetDistance1(
        this: *const S2Cell,
        a: *const S2Point,
        b: *const S2Point,
    ) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell14GetMaxDistanceERK7Vector3IdES3_"]
    pub fn S2Cell_GetMaxDistance1(
        this: *const S2Cell,
        a: *const S2Point,
        b: *const S2Point,
    ) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell11GetDistanceERKS_"]
    pub fn S2Cell_GetDistance2(this: *const S2Cell, target: *const S2Cell) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell14GetMaxDistanceERKS_"]
    pub fn S2Cell_GetMaxDistance2(this: *const S2Cell, target: *const S2Cell) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell6EncodeEP7Encoder"]
    pub fn S2Cell_Encode(this: *const S2Cell, encoder: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN6S2Cell6DecodeEP7Decoder"]
    pub fn S2Cell_Decode(this: *mut S2Cell, decoder: *mut Decoder) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6S2CellC1E8S2CellId"]
    pub fn S2Cell_S2Cell(this: *mut S2Cell, id: S2CellId);
}
impl S2Cell {
    #[inline]
    pub unsafe fn GetSizeIJ(&self) -> ::std::os::raw::c_int {
        S2Cell_GetSizeIJ(self)
    }
    #[inline]
    pub unsafe fn GetSizeST(&self) -> f64 {
        S2Cell_GetSizeST(self)
    }
    #[inline]
    pub unsafe fn GetEdgeRaw(&self, k: ::std::os::raw::c_int) -> S2Point {
        S2Cell_GetEdgeRaw(self, k)
    }
    #[inline]
    pub unsafe fn Subdivide(&self, children: *mut S2Cell) -> bool {
        S2Cell_Subdivide(self, children)
    }
    #[inline]
    pub unsafe fn GetCenterRaw(&self) -> S2Point {
        S2Cell_GetCenterRaw(self)
    }
    #[inline]
    pub unsafe fn AverageArea(level: ::std::os::raw::c_int) -> f64 {
        S2Cell_AverageArea(level)
    }
    #[inline]
    pub unsafe fn ApproxArea(&self) -> f64 {
        S2Cell_ApproxArea(self)
    }
    #[inline]
    pub unsafe fn ExactArea(&self) -> f64 {
        S2Cell_ExactArea(self)
    }
    #[inline]
    pub unsafe fn GetDistance(&self, target: *const S2Point) -> S1ChordAngle {
        S2Cell_GetDistance(self, target)
    }
    #[inline]
    pub unsafe fn GetBoundaryDistance(&self, target: *const S2Point) -> S1ChordAngle {
        S2Cell_GetBoundaryDistance(self, target)
    }
    #[inline]
    pub unsafe fn GetMaxDistance(&self, target: *const S2Point) -> S1ChordAngle {
        S2Cell_GetMaxDistance(self, target)
    }
    #[inline]
    pub unsafe fn GetDistance1(&self, a: *const S2Point, b: *const S2Point) -> S1ChordAngle {
        S2Cell_GetDistance1(self, a, b)
    }
    #[inline]
    pub unsafe fn GetMaxDistance1(&self, a: *const S2Point, b: *const S2Point) -> S1ChordAngle {
        S2Cell_GetMaxDistance1(self, a, b)
    }
    #[inline]
    pub unsafe fn GetDistance2(&self, target: *const S2Cell) -> S1ChordAngle {
        S2Cell_GetDistance2(self, target)
    }
    #[inline]
    pub unsafe fn GetMaxDistance2(&self, target: *const S2Cell) -> S1ChordAngle {
        S2Cell_GetMaxDistance2(self, target)
    }
    #[inline]
    pub unsafe fn Encode(&self, encoder: *mut Encoder) {
        S2Cell_Encode(self, encoder)
    }
    #[inline]
    pub unsafe fn Decode(&mut self, decoder: *mut Decoder) -> bool {
        S2Cell_Decode(self, decoder)
    }
    #[inline]
    pub unsafe fn new(id: S2CellId) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2Cell_S2Cell(__bindgen_tmp.as_mut_ptr(), id);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell5CloneEv"]
    pub fn S2Cell_Clone(this: *mut ::std::os::raw::c_void) -> *mut S2Cell;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell11GetCapBoundEv"]
    pub fn S2Cell_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell12GetRectBoundEv"]
    pub fn S2Cell_GetRectBound(this: *mut ::std::os::raw::c_void) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell8ContainsERKS_"]
    pub fn S2Cell_Contains(this: *mut ::std::os::raw::c_void, cell: *const S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell12MayIntersectERKS_"]
    pub fn S2Cell_MayIntersect(this: *mut ::std::os::raw::c_void, cell: *const S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6S2Cell8ContainsERK7Vector3IdE"]
    pub fn S2Cell_Contains1(this: *mut ::std::os::raw::c_void, p: *const S2Point) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2Cap {
    pub _base: S2Region,
    pub center_: S2Point,
    pub radius_: S1ChordAngle,
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap9FromPointERK7Vector3IdE"]
    pub fn S2Cap_FromPoint(center: *const S2Point) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap16FromCenterHeightERK7Vector3IdEd"]
    pub fn S2Cap_FromCenterHeight(center: *const S2Point, height: f64) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap14FromCenterAreaERK7Vector3IdEd"]
    pub fn S2Cap_FromCenterArea(center: *const S2Point, area: f64) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap5EmptyEv"]
    pub fn S2Cap_Empty() -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap4FullEv"]
    pub fn S2Cap_Full() -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap6heightEv"]
    pub fn S2Cap_height(this: *const S2Cap) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap9GetRadiusEv"]
    pub fn S2Cap_GetRadius(this: *const S2Cap) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap7GetAreaEv"]
    pub fn S2Cap_GetArea(this: *const S2Cap) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap11GetCentroidEv"]
    pub fn S2Cap_GetCentroid(this: *const S2Cap) -> S2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap8is_validEv"]
    pub fn S2Cap_is_valid(this: *const S2Cap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap8is_emptyEv"]
    pub fn S2Cap_is_empty(this: *const S2Cap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap7is_fullEv"]
    pub fn S2Cap_is_full(this: *const S2Cap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap10ComplementEv"]
    pub fn S2Cap_Complement(this: *const S2Cap) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap8ContainsERKS_"]
    pub fn S2Cap_Contains(this: *const S2Cap, other: *const S2Cap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap10IntersectsERKS_"]
    pub fn S2Cap_Intersects(this: *const S2Cap, other: *const S2Cap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap18InteriorIntersectsERKS_"]
    pub fn S2Cap_InteriorIntersects(this: *const S2Cap, other: *const S2Cap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap16InteriorContainsERK7Vector3IdE"]
    pub fn S2Cap_InteriorContains(this: *const S2Cap, p: *const S2Point) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap8AddPointERK7Vector3IdE"]
    pub fn S2Cap_AddPoint(this: *mut S2Cap, p: *const S2Point);
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap6AddCapERKS_"]
    pub fn S2Cap_AddCap(this: *mut S2Cap, other: *const S2Cap);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap8ExpandedE7S1Angle"]
    pub fn S2Cap_Expanded(this: *const S2Cap, distance: S1Angle) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap5UnionERKS_"]
    pub fn S2Cap_Union(this: *const S2Cap, other: *const S2Cap) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap6EncodeEP7Encoder"]
    pub fn S2Cap_Encode(this: *const S2Cap, encoder: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2Cap6DecodeEP7Decoder"]
    pub fn S2Cap_Decode(this: *mut S2Cap, decoder: *mut Decoder) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap12ApproxEqualsERKS_7S1Angle"]
    pub fn S2Cap_ApproxEquals(this: *const S2Cap, other: *const S2Cap, max_error: S1Angle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2CapC1ERK7Vector3IdE7S1Angle"]
    pub fn S2Cap_S2Cap(this: *mut S2Cap, center: *const S2Point, radius: S1Angle);
}
extern "C" {
    #[link_name = "\u{1}_ZN5S2CapC1ERK7Vector3IdE12S1ChordAngle"]
    pub fn S2Cap_S2Cap1(this: *mut S2Cap, center: *const S2Point, radius: S1ChordAngle);
}
impl S2Cap {
    #[inline]
    pub unsafe fn FromPoint(center: *const S2Point) -> S2Cap {
        S2Cap_FromPoint(center)
    }
    #[inline]
    pub unsafe fn FromCenterHeight(center: *const S2Point, height: f64) -> S2Cap {
        S2Cap_FromCenterHeight(center, height)
    }
    #[inline]
    pub unsafe fn FromCenterArea(center: *const S2Point, area: f64) -> S2Cap {
        S2Cap_FromCenterArea(center, area)
    }
    #[inline]
    pub unsafe fn Empty() -> S2Cap {
        S2Cap_Empty()
    }
    #[inline]
    pub unsafe fn Full() -> S2Cap {
        S2Cap_Full()
    }
    #[inline]
    pub unsafe fn height(&self) -> f64 {
        S2Cap_height(self)
    }
    #[inline]
    pub unsafe fn GetRadius(&self) -> S1Angle {
        S2Cap_GetRadius(self)
    }
    #[inline]
    pub unsafe fn GetArea(&self) -> f64 {
        S2Cap_GetArea(self)
    }
    #[inline]
    pub unsafe fn GetCentroid(&self) -> S2Point {
        S2Cap_GetCentroid(self)
    }
    #[inline]
    pub unsafe fn is_valid(&self) -> bool {
        S2Cap_is_valid(self)
    }
    #[inline]
    pub unsafe fn is_empty(&self) -> bool {
        S2Cap_is_empty(self)
    }
    #[inline]
    pub unsafe fn is_full(&self) -> bool {
        S2Cap_is_full(self)
    }
    #[inline]
    pub unsafe fn Complement(&self) -> S2Cap {
        S2Cap_Complement(self)
    }
    #[inline]
    pub unsafe fn Contains(&self, other: *const S2Cap) -> bool {
        S2Cap_Contains(self, other)
    }
    #[inline]
    pub unsafe fn Intersects(&self, other: *const S2Cap) -> bool {
        S2Cap_Intersects(self, other)
    }
    #[inline]
    pub unsafe fn InteriorIntersects(&self, other: *const S2Cap) -> bool {
        S2Cap_InteriorIntersects(self, other)
    }
    #[inline]
    pub unsafe fn InteriorContains(&self, p: *const S2Point) -> bool {
        S2Cap_InteriorContains(self, p)
    }
    #[inline]
    pub unsafe fn AddPoint(&mut self, p: *const S2Point) {
        S2Cap_AddPoint(self, p)
    }
    #[inline]
    pub unsafe fn AddCap(&mut self, other: *const S2Cap) {
        S2Cap_AddCap(self, other)
    }
    #[inline]
    pub unsafe fn Expanded(&self, distance: S1Angle) -> S2Cap {
        S2Cap_Expanded(self, distance)
    }
    #[inline]
    pub unsafe fn Union(&self, other: *const S2Cap) -> S2Cap {
        S2Cap_Union(self, other)
    }
    #[inline]
    pub unsafe fn Encode(&self, encoder: *mut Encoder) {
        S2Cap_Encode(self, encoder)
    }
    #[inline]
    pub unsafe fn Decode(&mut self, decoder: *mut Decoder) -> bool {
        S2Cap_Decode(self, decoder)
    }
    #[inline]
    pub unsafe fn ApproxEquals(&self, other: *const S2Cap, max_error: S1Angle) -> bool {
        S2Cap_ApproxEquals(self, other, max_error)
    }
    #[inline]
    pub unsafe fn new(center: *const S2Point, radius: S1Angle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2Cap_S2Cap(__bindgen_tmp.as_mut_ptr(), center, radius);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(center: *const S2Point, radius: S1ChordAngle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2Cap_S2Cap1(__bindgen_tmp.as_mut_ptr(), center, radius);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap5CloneEv"]
    pub fn S2Cap_Clone(this: *mut ::std::os::raw::c_void) -> *mut S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap11GetCapBoundEv"]
    pub fn S2Cap_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap12GetRectBoundEv"]
    pub fn S2Cap_GetRectBound(this: *mut ::std::os::raw::c_void) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap17GetCellUnionBoundEPSt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2Cap_GetCellUnionBound(this: *mut ::std::os::raw::c_void, cell_ids: *mut [u64; 3usize]);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap8ContainsERK6S2Cell"]
    pub fn S2Cap_Contains1(this: *mut ::std::os::raw::c_void, cell: *const S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap12MayIntersectERK6S2Cell"]
    pub fn S2Cap_MayIntersect(this: *mut ::std::os::raw::c_void, cell: *const S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5S2Cap8ContainsERK7Vector3IdE"]
    pub fn S2Cap_Contains2(this: *mut ::std::os::raw::c_void, p: *const S2Point) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2CellUnion {
    pub _base: S2Region,
    pub cell_ids_: [u64; 3usize],
}
pub const S2CellUnion_VerbatimFlag_VERBATIM: S2CellUnion_VerbatimFlag = 0;
pub type S2CellUnion_VerbatimFlag = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion11WholeSphereEv"]
    pub fn S2CellUnion_WholeSphere() -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion14FromNormalizedESt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2CellUnion_FromNormalized(cell_ids: [u64; 3usize]) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion12FromVerbatimESt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2CellUnion_FromVerbatim(cell_ids: [u64; 3usize]) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion10FromMinMaxE8S2CellIdS0_"]
    pub fn S2CellUnion_FromMinMax(min_id: S2CellId, max_id: S2CellId) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion12FromBeginEndE8S2CellIdS0_"]
    pub fn S2CellUnion_FromBeginEnd(begin: S2CellId, end: S2CellId) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion4InitESt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2CellUnion_Init(this: *mut S2CellUnion, cell_ids: [u64; 3usize]);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion4InitERKSt6vectorIySaIyEE"]
    pub fn S2CellUnion_Init1(this: *mut S2CellUnion, cell_ids: *const u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion14InitFromMinMaxE8S2CellIdS0_"]
    pub fn S2CellUnion_InitFromMinMax(this: *mut S2CellUnion, min_id: S2CellId, max_id: S2CellId);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion16InitFromBeginEndE8S2CellIdS0_"]
    pub fn S2CellUnion_InitFromBeginEnd(this: *mut S2CellUnion, begin: S2CellId, end: S2CellId);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion5ClearEv"]
    pub fn S2CellUnion_Clear(this: *mut S2CellUnion);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion7ReleaseEv"]
    pub fn S2CellUnion_Release(this: *mut S2CellUnion) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion5beginEv"]
    pub fn S2CellUnion_begin(
        this: *const S2CellUnion,
    ) -> __gnu_cxx___normal_iterator<const_pointer>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion3endEv"]
    pub fn S2CellUnion_end(this: *const S2CellUnion) -> __gnu_cxx___normal_iterator<const_pointer>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion7IsValidEv"]
    pub fn S2CellUnion_IsValid(this: *const S2CellUnion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion12IsNormalizedEv"]
    pub fn S2CellUnion_IsNormalized(this: *const S2CellUnion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion9NormalizeEv"]
    pub fn S2CellUnion_Normalize(this: *mut S2CellUnion);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion11DenormalizeEiiPSt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2CellUnion_Denormalize(
        this: *const S2CellUnion,
        min_level: ::std::os::raw::c_int,
        level_mod: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion4PackEi"]
    pub fn S2CellUnion_Pack(this: *mut S2CellUnion, excess: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion8ContainsE8S2CellId"]
    pub fn S2CellUnion_Contains(this: *const S2CellUnion, id: S2CellId) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion10IntersectsE8S2CellId"]
    pub fn S2CellUnion_Intersects(this: *const S2CellUnion, id: S2CellId) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion8ContainsERKS_"]
    pub fn S2CellUnion_Contains1(this: *const S2CellUnion, y: *const S2CellUnion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion10IntersectsERKS_"]
    pub fn S2CellUnion_Intersects1(this: *const S2CellUnion, y: *const S2CellUnion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion5UnionERKS_"]
    pub fn S2CellUnion_Union(this: *const S2CellUnion, y: *const S2CellUnion) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion12IntersectionERKS_"]
    pub fn S2CellUnion_Intersection(this: *const S2CellUnion, y: *const S2CellUnion)
        -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion12IntersectionE8S2CellId"]
    pub fn S2CellUnion_Intersection1(this: *const S2CellUnion, id: S2CellId) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion10DifferenceERKS_"]
    pub fn S2CellUnion_Difference(this: *const S2CellUnion, y: *const S2CellUnion) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion6ExpandEi"]
    pub fn S2CellUnion_Expand(this: *mut S2CellUnion, expand_level: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion6ExpandE7S1Anglei"]
    pub fn S2CellUnion_Expand1(
        this: *mut S2CellUnion,
        min_radius: S1Angle,
        max_level_diff: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion16LeafCellsCoveredEv"]
    pub fn S2CellUnion_LeafCellsCovered(this: *const S2CellUnion) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion16AverageBasedAreaEv"]
    pub fn S2CellUnion_AverageBasedArea(this: *const S2CellUnion) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion10ApproxAreaEv"]
    pub fn S2CellUnion_ApproxArea(this: *const S2CellUnion) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion9ExactAreaEv"]
    pub fn S2CellUnion_ExactArea(this: *const S2CellUnion) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion6EncodeEP7Encoder"]
    pub fn S2CellUnion_Encode(this: *const S2CellUnion, encoder: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion6DecodeEP7Decoder"]
    pub fn S2CellUnion_Decode(this: *mut S2CellUnion, decoder: *mut Decoder) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion9NormalizeEPSt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2CellUnion_Normalize1(cell_ids: *mut [u64; 3usize]);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion11DenormalizeERKSt6vectorI8S2CellIdSaIS1_EEiiPS3_"]
    pub fn S2CellUnion_Denormalize1(
        in_: *const [u64; 3usize],
        min_level: ::std::os::raw::c_int,
        level_mod: ::std::os::raw::c_int,
        out: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnion15GetIntersectionERKSt6vectorI8S2CellIdSaIS1_EES5_PS3_"]
    pub fn S2CellUnion_GetIntersection(
        x: *const [u64; 3usize],
        y: *const [u64; 3usize],
        out: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion8ToStringB5cxx11Ev"]
    pub fn S2CellUnion_ToString(this: *const S2CellUnion) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnionC1ESt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2CellUnion_S2CellUnion(this: *mut S2CellUnion, cell_ids: [u64; 3usize]);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellUnionC1ERKSt6vectorIySaIyEE"]
    pub fn S2CellUnion_S2CellUnion1(this: *mut S2CellUnion, cell_ids: *const u8);
}
impl S2CellUnion {
    #[inline]
    pub unsafe fn WholeSphere() -> S2CellUnion {
        S2CellUnion_WholeSphere()
    }
    #[inline]
    pub unsafe fn FromNormalized(cell_ids: [u64; 3usize]) -> S2CellUnion {
        S2CellUnion_FromNormalized(cell_ids)
    }
    #[inline]
    pub unsafe fn FromVerbatim(cell_ids: [u64; 3usize]) -> S2CellUnion {
        S2CellUnion_FromVerbatim(cell_ids)
    }
    #[inline]
    pub unsafe fn FromMinMax(min_id: S2CellId, max_id: S2CellId) -> S2CellUnion {
        S2CellUnion_FromMinMax(min_id, max_id)
    }
    #[inline]
    pub unsafe fn FromBeginEnd(begin: S2CellId, end: S2CellId) -> S2CellUnion {
        S2CellUnion_FromBeginEnd(begin, end)
    }
    #[inline]
    pub unsafe fn Init(&mut self, cell_ids: [u64; 3usize]) {
        S2CellUnion_Init(self, cell_ids)
    }
    #[inline]
    pub unsafe fn Init1(&mut self, cell_ids: *const u8) {
        S2CellUnion_Init1(self, cell_ids)
    }
    #[inline]
    pub unsafe fn InitFromMinMax(&mut self, min_id: S2CellId, max_id: S2CellId) {
        S2CellUnion_InitFromMinMax(self, min_id, max_id)
    }
    #[inline]
    pub unsafe fn InitFromBeginEnd(&mut self, begin: S2CellId, end: S2CellId) {
        S2CellUnion_InitFromBeginEnd(self, begin, end)
    }
    #[inline]
    pub unsafe fn Clear(&mut self) {
        S2CellUnion_Clear(self)
    }
    #[inline]
    pub unsafe fn Release(&mut self) -> [u64; 3usize] {
        S2CellUnion_Release(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> __gnu_cxx___normal_iterator<const_pointer> {
        S2CellUnion_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> __gnu_cxx___normal_iterator<const_pointer> {
        S2CellUnion_end(self)
    }
    #[inline]
    pub unsafe fn IsValid(&self) -> bool {
        S2CellUnion_IsValid(self)
    }
    #[inline]
    pub unsafe fn IsNormalized(&self) -> bool {
        S2CellUnion_IsNormalized(self)
    }
    #[inline]
    pub unsafe fn Normalize(&mut self) {
        S2CellUnion_Normalize(self)
    }
    #[inline]
    pub unsafe fn Denormalize(
        &self,
        min_level: ::std::os::raw::c_int,
        level_mod: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    ) {
        S2CellUnion_Denormalize(self, min_level, level_mod, output)
    }
    #[inline]
    pub unsafe fn Pack(&mut self, excess: ::std::os::raw::c_int) {
        S2CellUnion_Pack(self, excess)
    }
    #[inline]
    pub unsafe fn Contains(&self, id: S2CellId) -> bool {
        S2CellUnion_Contains(self, id)
    }
    #[inline]
    pub unsafe fn Intersects(&self, id: S2CellId) -> bool {
        S2CellUnion_Intersects(self, id)
    }
    #[inline]
    pub unsafe fn Contains1(&self, y: *const S2CellUnion) -> bool {
        S2CellUnion_Contains1(self, y)
    }
    #[inline]
    pub unsafe fn Intersects1(&self, y: *const S2CellUnion) -> bool {
        S2CellUnion_Intersects1(self, y)
    }
    #[inline]
    pub unsafe fn Union(&self, y: *const S2CellUnion) -> S2CellUnion {
        S2CellUnion_Union(self, y)
    }
    #[inline]
    pub unsafe fn Intersection(&self, y: *const S2CellUnion) -> S2CellUnion {
        S2CellUnion_Intersection(self, y)
    }
    #[inline]
    pub unsafe fn Intersection1(&self, id: S2CellId) -> S2CellUnion {
        S2CellUnion_Intersection1(self, id)
    }
    #[inline]
    pub unsafe fn Difference(&self, y: *const S2CellUnion) -> S2CellUnion {
        S2CellUnion_Difference(self, y)
    }
    #[inline]
    pub unsafe fn Expand(&mut self, expand_level: ::std::os::raw::c_int) {
        S2CellUnion_Expand(self, expand_level)
    }
    #[inline]
    pub unsafe fn Expand1(&mut self, min_radius: S1Angle, max_level_diff: ::std::os::raw::c_int) {
        S2CellUnion_Expand1(self, min_radius, max_level_diff)
    }
    #[inline]
    pub unsafe fn LeafCellsCovered(&self) -> uint64 {
        S2CellUnion_LeafCellsCovered(self)
    }
    #[inline]
    pub unsafe fn AverageBasedArea(&self) -> f64 {
        S2CellUnion_AverageBasedArea(self)
    }
    #[inline]
    pub unsafe fn ApproxArea(&self) -> f64 {
        S2CellUnion_ApproxArea(self)
    }
    #[inline]
    pub unsafe fn ExactArea(&self) -> f64 {
        S2CellUnion_ExactArea(self)
    }
    #[inline]
    pub unsafe fn Encode(&self, encoder: *mut Encoder) {
        S2CellUnion_Encode(self, encoder)
    }
    #[inline]
    pub unsafe fn Decode(&mut self, decoder: *mut Decoder) -> bool {
        S2CellUnion_Decode(self, decoder)
    }
    #[inline]
    pub unsafe fn Normalize1(cell_ids: *mut [u64; 3usize]) {
        S2CellUnion_Normalize1(cell_ids)
    }
    #[inline]
    pub unsafe fn Denormalize1(
        in_: *const [u64; 3usize],
        min_level: ::std::os::raw::c_int,
        level_mod: ::std::os::raw::c_int,
        out: *mut [u64; 3usize],
    ) {
        S2CellUnion_Denormalize1(in_, min_level, level_mod, out)
    }
    #[inline]
    pub unsafe fn GetIntersection(
        x: *const [u64; 3usize],
        y: *const [u64; 3usize],
        out: *mut [u64; 3usize],
    ) {
        S2CellUnion_GetIntersection(x, y, out)
    }
    #[inline]
    pub unsafe fn ToString(&self) -> std_string {
        S2CellUnion_ToString(self)
    }
    #[inline]
    pub unsafe fn new(cell_ids: [u64; 3usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellUnion_S2CellUnion(__bindgen_tmp.as_mut_ptr(), cell_ids);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(cell_ids: *const u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellUnion_S2CellUnion1(__bindgen_tmp.as_mut_ptr(), cell_ids);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion5CloneEv"]
    pub fn S2CellUnion_Clone(this: *mut ::std::os::raw::c_void) -> *mut S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion11GetCapBoundEv"]
    pub fn S2CellUnion_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion12GetRectBoundEv"]
    pub fn S2CellUnion_GetRectBound(this: *mut ::std::os::raw::c_void) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion8ContainsERK6S2Cell"]
    pub fn S2CellUnion_Contains2(this: *mut ::std::os::raw::c_void, cell: *const S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion12MayIntersectERK6S2Cell"]
    pub fn S2CellUnion_MayIntersect(this: *mut ::std::os::raw::c_void, cell: *const S2Cell)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellUnion8ContainsERK7Vector3IdE"]
    pub fn S2CellUnion_Contains3(this: *mut ::std::os::raw::c_void, p: *const S2Point) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2CellIndex {
    pub cell_tree_: [u64; 3usize],
    pub range_nodes_: [u64; 3usize],
}
pub type S2CellIndex_Label = int32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2CellIndex_LabelledCell {
    pub cell_id: S2CellId,
    pub label: S2CellIndex_Label,
}
pub type S2CellIndex_CellVisitor = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2CellIndex_CellNode {
    pub cell_id: S2CellId,
    pub label: S2CellIndex_Label,
    pub parent: int32,
}
#[repr(C)]
pub struct S2CellIndex_CellIterator {
    pub cell_it_: __gnu_cxx___normal_iterator<const_pointer>,
    pub cell_end_: __gnu_cxx___normal_iterator<const_pointer>,
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex12CellIterator7cell_idEv"]
    pub fn S2CellIndex_CellIterator_cell_id(this: *const S2CellIndex_CellIterator) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex12CellIterator5labelEv"]
    pub fn S2CellIndex_CellIterator_label(
        this: *const S2CellIndex_CellIterator,
    ) -> S2CellIndex_Label;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex12CellIterator13labelled_cellEv"]
    pub fn S2CellIndex_CellIterator_labelled_cell(
        this: *const S2CellIndex_CellIterator,
    ) -> S2CellIndex_LabelledCell;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex12CellIterator4doneEv"]
    pub fn S2CellIndex_CellIterator_done(this: *const S2CellIndex_CellIterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex12CellIterator4NextEv"]
    pub fn S2CellIndex_CellIterator_Next(this: *mut S2CellIndex_CellIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex12CellIteratorC1EPKS_"]
    pub fn S2CellIndex_CellIterator_CellIterator(
        this: *mut S2CellIndex_CellIterator,
        index: *const S2CellIndex,
    );
}
impl S2CellIndex_CellIterator {
    #[inline]
    pub unsafe fn cell_id(&self) -> S2CellId {
        S2CellIndex_CellIterator_cell_id(self)
    }
    #[inline]
    pub unsafe fn label(&self) -> S2CellIndex_Label {
        S2CellIndex_CellIterator_label(self)
    }
    #[inline]
    pub unsafe fn labelled_cell(&self) -> S2CellIndex_LabelledCell {
        S2CellIndex_CellIterator_labelled_cell(self)
    }
    #[inline]
    pub unsafe fn done(&self) -> bool {
        S2CellIndex_CellIterator_done(self)
    }
    #[inline]
    pub unsafe fn Next(&mut self) {
        S2CellIndex_CellIterator_Next(self)
    }
    #[inline]
    pub unsafe fn new(index: *const S2CellIndex) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellIndex_CellIterator_CellIterator(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct S2CellIndex_RangeIterator {
    pub range_nodes_: *const [u64; 3usize],
    pub it_: __gnu_cxx___normal_iterator<const_pointer>,
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex13RangeIterator8start_idEv"]
    pub fn S2CellIndex_RangeIterator_start_id(this: *const S2CellIndex_RangeIterator) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex13RangeIterator8limit_idEv"]
    pub fn S2CellIndex_RangeIterator_limit_id(this: *const S2CellIndex_RangeIterator) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex13RangeIterator4doneEv"]
    pub fn S2CellIndex_RangeIterator_done(this: *const S2CellIndex_RangeIterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex13RangeIterator5BeginEv"]
    pub fn S2CellIndex_RangeIterator_Begin(this: *mut S2CellIndex_RangeIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex13RangeIterator6FinishEv"]
    pub fn S2CellIndex_RangeIterator_Finish(this: *mut S2CellIndex_RangeIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex13RangeIterator4NextEv"]
    pub fn S2CellIndex_RangeIterator_Next(this: *mut S2CellIndex_RangeIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex13RangeIterator4PrevEv"]
    pub fn S2CellIndex_RangeIterator_Prev(this: *mut S2CellIndex_RangeIterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex13RangeIterator4SeekE8S2CellId"]
    pub fn S2CellIndex_RangeIterator_Seek(this: *mut S2CellIndex_RangeIterator, target: S2CellId);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex13RangeIterator8is_emptyEv"]
    pub fn S2CellIndex_RangeIterator_is_empty(this: *const S2CellIndex_RangeIterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex13RangeIterator7AdvanceEi"]
    pub fn S2CellIndex_RangeIterator_Advance(
        this: *mut S2CellIndex_RangeIterator,
        n: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex13RangeIteratorC1EPKS_"]
    pub fn S2CellIndex_RangeIterator_RangeIterator(
        this: *mut S2CellIndex_RangeIterator,
        index: *const S2CellIndex,
    );
}
impl S2CellIndex_RangeIterator {
    #[inline]
    pub unsafe fn start_id(&self) -> S2CellId {
        S2CellIndex_RangeIterator_start_id(self)
    }
    #[inline]
    pub unsafe fn limit_id(&self) -> S2CellId {
        S2CellIndex_RangeIterator_limit_id(self)
    }
    #[inline]
    pub unsafe fn done(&self) -> bool {
        S2CellIndex_RangeIterator_done(self)
    }
    #[inline]
    pub unsafe fn Begin(&mut self) {
        S2CellIndex_RangeIterator_Begin(self)
    }
    #[inline]
    pub unsafe fn Finish(&mut self) {
        S2CellIndex_RangeIterator_Finish(self)
    }
    #[inline]
    pub unsafe fn Next(&mut self) {
        S2CellIndex_RangeIterator_Next(self)
    }
    #[inline]
    pub unsafe fn Prev(&mut self) -> bool {
        S2CellIndex_RangeIterator_Prev(self)
    }
    #[inline]
    pub unsafe fn Seek(&mut self, target: S2CellId) {
        S2CellIndex_RangeIterator_Seek(self, target)
    }
    #[inline]
    pub unsafe fn is_empty(&self) -> bool {
        S2CellIndex_RangeIterator_is_empty(self)
    }
    #[inline]
    pub unsafe fn Advance(&mut self, n: ::std::os::raw::c_int) -> bool {
        S2CellIndex_RangeIterator_Advance(self, n)
    }
    #[inline]
    pub unsafe fn new(index: *const S2CellIndex) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellIndex_RangeIterator_RangeIterator(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct S2CellIndex_NonEmptyRangeIterator {
    pub _base: S2CellIndex_RangeIterator,
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex21NonEmptyRangeIterator5BeginEv"]
    pub fn S2CellIndex_NonEmptyRangeIterator_Begin(this: *mut S2CellIndex_NonEmptyRangeIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex21NonEmptyRangeIterator4NextEv"]
    pub fn S2CellIndex_NonEmptyRangeIterator_Next(this: *mut S2CellIndex_NonEmptyRangeIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex21NonEmptyRangeIterator4PrevEv"]
    pub fn S2CellIndex_NonEmptyRangeIterator_Prev(
        this: *mut S2CellIndex_NonEmptyRangeIterator,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex21NonEmptyRangeIterator4SeekE8S2CellId"]
    pub fn S2CellIndex_NonEmptyRangeIterator_Seek(
        this: *mut S2CellIndex_NonEmptyRangeIterator,
        target: S2CellId,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex21NonEmptyRangeIteratorC1EPKS_"]
    pub fn S2CellIndex_NonEmptyRangeIterator_NonEmptyRangeIterator(
        this: *mut S2CellIndex_NonEmptyRangeIterator,
        index: *const S2CellIndex,
    );
}
impl S2CellIndex_NonEmptyRangeIterator {
    #[inline]
    pub unsafe fn Begin(&mut self) {
        S2CellIndex_NonEmptyRangeIterator_Begin(self)
    }
    #[inline]
    pub unsafe fn Next(&mut self) {
        S2CellIndex_NonEmptyRangeIterator_Next(self)
    }
    #[inline]
    pub unsafe fn Prev(&mut self) -> bool {
        S2CellIndex_NonEmptyRangeIterator_Prev(self)
    }
    #[inline]
    pub unsafe fn Seek(&mut self, target: S2CellId) {
        S2CellIndex_NonEmptyRangeIterator_Seek(self, target)
    }
    #[inline]
    pub unsafe fn new(index: *const S2CellIndex) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellIndex_NonEmptyRangeIterator_NonEmptyRangeIterator(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2CellIndex_ContentsIterator {
    pub cell_tree_: *const [u64; 3usize],
    pub prev_start_id_: S2CellId,
    pub node_cutoff_: int32,
    pub next_node_cutoff_: int32,
    pub node_: S2CellIndex_CellNode,
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex16ContentsIterator4InitEPKS_"]
    pub fn S2CellIndex_ContentsIterator_Init(
        this: *mut S2CellIndex_ContentsIterator,
        index: *const S2CellIndex,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex16ContentsIterator5ClearEv"]
    pub fn S2CellIndex_ContentsIterator_Clear(this: *mut S2CellIndex_ContentsIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex16ContentsIterator10StartUnionERKNS_13RangeIteratorE"]
    pub fn S2CellIndex_ContentsIterator_StartUnion(
        this: *mut S2CellIndex_ContentsIterator,
        range: *const S2CellIndex_RangeIterator,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex16ContentsIterator7cell_idEv"]
    pub fn S2CellIndex_ContentsIterator_cell_id(
        this: *const S2CellIndex_ContentsIterator,
    ) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex16ContentsIterator5labelEv"]
    pub fn S2CellIndex_ContentsIterator_label(
        this: *const S2CellIndex_ContentsIterator,
    ) -> S2CellIndex_Label;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex16ContentsIterator13labelled_cellEv"]
    pub fn S2CellIndex_ContentsIterator_labelled_cell(
        this: *const S2CellIndex_ContentsIterator,
    ) -> S2CellIndex_LabelledCell;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex16ContentsIterator4doneEv"]
    pub fn S2CellIndex_ContentsIterator_done(this: *const S2CellIndex_ContentsIterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex16ContentsIterator4NextEv"]
    pub fn S2CellIndex_ContentsIterator_Next(this: *mut S2CellIndex_ContentsIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex16ContentsIteratorC1Ev"]
    pub fn S2CellIndex_ContentsIterator_ContentsIterator(this: *mut S2CellIndex_ContentsIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex16ContentsIteratorC1EPKS_"]
    pub fn S2CellIndex_ContentsIterator_ContentsIterator1(
        this: *mut S2CellIndex_ContentsIterator,
        index: *const S2CellIndex,
    );
}
impl S2CellIndex_ContentsIterator {
    #[inline]
    pub unsafe fn Init(&mut self, index: *const S2CellIndex) {
        S2CellIndex_ContentsIterator_Init(self, index)
    }
    #[inline]
    pub unsafe fn Clear(&mut self) {
        S2CellIndex_ContentsIterator_Clear(self)
    }
    #[inline]
    pub unsafe fn StartUnion(&mut self, range: *const S2CellIndex_RangeIterator) {
        S2CellIndex_ContentsIterator_StartUnion(self, range)
    }
    #[inline]
    pub unsafe fn cell_id(&self) -> S2CellId {
        S2CellIndex_ContentsIterator_cell_id(self)
    }
    #[inline]
    pub unsafe fn label(&self) -> S2CellIndex_Label {
        S2CellIndex_ContentsIterator_label(self)
    }
    #[inline]
    pub unsafe fn labelled_cell(&self) -> S2CellIndex_LabelledCell {
        S2CellIndex_ContentsIterator_labelled_cell(self)
    }
    #[inline]
    pub unsafe fn done(&self) -> bool {
        S2CellIndex_ContentsIterator_done(self)
    }
    #[inline]
    pub unsafe fn Next(&mut self) {
        S2CellIndex_ContentsIterator_Next(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellIndex_ContentsIterator_ContentsIterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(index: *const S2CellIndex) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellIndex_ContentsIterator_ContentsIterator1(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2CellIndex_RangeNode {
    pub start_id: S2CellId,
    pub contents: int32,
}
pub const S2CellIndex_kDoneContents: S2CellIndex_Label = -1;
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex9num_cellsEv"]
    pub fn S2CellIndex_num_cells(this: *const S2CellIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex3AddE8S2CellIdi"]
    pub fn S2CellIndex_Add(this: *mut S2CellIndex, cell_id: S2CellId, label: S2CellIndex_Label);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex3AddERK11S2CellUnioni"]
    pub fn S2CellIndex_Add1(
        this: *mut S2CellIndex,
        cell_ids: *const S2CellUnion,
        label: S2CellIndex_Label,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex5BuildEv"]
    pub fn S2CellIndex_Build(this: *mut S2CellIndex);
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndex5ClearEv"]
    pub fn S2CellIndex_Clear(this: *mut S2CellIndex);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex22VisitIntersectingCellsERK11S2CellUnionRKSt8functionIFb8S2CellIdiEE"]
    pub fn S2CellIndex_VisitIntersectingCells(
        this: *const S2CellIndex,
        target: *const S2CellUnion,
        visitor: *const S2CellIndex_CellVisitor,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex21GetIntersectingLabelsERK11S2CellUnion"]
    pub fn S2CellIndex_GetIntersectingLabels(
        this: *const S2CellIndex,
        target: *const S2CellUnion,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11S2CellIndex21GetIntersectingLabelsERK11S2CellUnionPN4absl13flat_hash_setIiNS3_13hash_internal4HashIiEESt8equal_toIiESaIiEEE"]
    pub fn S2CellIndex_GetIntersectingLabels1(
        this: *const S2CellIndex,
        target: *const S2CellUnion,
        labels: *mut u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11S2CellIndexC1Ev"]
    pub fn S2CellIndex_S2CellIndex(this: *mut S2CellIndex);
}
impl S2CellIndex {
    #[inline]
    pub unsafe fn num_cells(&self) -> ::std::os::raw::c_int {
        S2CellIndex_num_cells(self)
    }
    #[inline]
    pub unsafe fn Add(&mut self, cell_id: S2CellId, label: S2CellIndex_Label) {
        S2CellIndex_Add(self, cell_id, label)
    }
    #[inline]
    pub unsafe fn Add1(&mut self, cell_ids: *const S2CellUnion, label: S2CellIndex_Label) {
        S2CellIndex_Add1(self, cell_ids, label)
    }
    #[inline]
    pub unsafe fn Build(&mut self) {
        S2CellIndex_Build(self)
    }
    #[inline]
    pub unsafe fn Clear(&mut self) {
        S2CellIndex_Clear(self)
    }
    #[inline]
    pub unsafe fn VisitIntersectingCells(
        &self,
        target: *const S2CellUnion,
        visitor: *const S2CellIndex_CellVisitor,
    ) -> bool {
        S2CellIndex_VisitIntersectingCells(self, target, visitor)
    }
    #[inline]
    pub unsafe fn GetIntersectingLabels(&self, target: *const S2CellUnion) -> u8 {
        S2CellIndex_GetIntersectingLabels(self, target)
    }
    #[inline]
    pub unsafe fn GetIntersectingLabels1(&self, target: *const S2CellUnion, labels: *mut u8) {
        S2CellIndex_GetIntersectingLabels1(self, target, labels)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2CellIndex_S2CellIndex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct S2Shape__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct S2Shape {
    pub vtable_: *const S2Shape__bindgen_vtable,
    pub id_: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2Shape_Edge {
    pub v0: S2Point,
    pub v1: S2Point,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2Shape_Chain {
    pub start: int32,
    pub length: int32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2Shape_ChainPosition {
    pub chain_id: int32,
    pub offset: int32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2Shape_ReferencePoint {
    pub point: S2Point,
    pub contained: bool,
}
pub type S2Shape_TypeTag = uint32;
pub const S2Shape_kNoTypeTag: S2Shape_TypeTag = 0;
pub const S2Shape_kNextAvailableTypeTag: S2Shape_TypeTag = 6;
pub const S2Shape_kMinUserTypeTag: S2Shape_TypeTag = 8192;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtl_compact_array {
    pub _address: u8,
}
pub type gtl_compact_array_Base = u8;
pub type gtl_compact_array_value_type = u8;
pub type gtl_compact_array_allocator_type = u8;
pub type gtl_compact_array_pointer = u8;
pub type gtl_compact_array_const_pointer = u8;
pub type gtl_compact_array_reference = u8;
pub type gtl_compact_array_const_reference = u8;
pub type gtl_compact_array_size_type = u8;
pub type gtl_compact_array_iterator = u8;
pub type gtl_compact_array_const_iterator = u8;
pub type gtl_compact_array_reverse_iterator = u8;
pub type gtl_compact_array_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtl_dense_hash_set {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtl_dense_hash_set_Identity {
    pub _address: u8,
}
pub type gtl_dense_hash_set_Identity_result_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtl_dense_hash_set_SetKey {
    pub _address: u8,
}
pub type gtl_dense_hash_set_ht = u8;
pub type gtl_dense_hash_set_key_type = u8;
pub type gtl_dense_hash_set_value_type = u8;
pub type gtl_dense_hash_set_hasher = u8;
pub type gtl_dense_hash_set_key_equal = u8;
pub type gtl_dense_hash_set_allocator_type = u8;
pub type gtl_dense_hash_set_size_type = u8;
pub type gtl_dense_hash_set_difference_type = u8;
pub type gtl_dense_hash_set_pointer = u8;
pub type gtl_dense_hash_set_const_pointer = u8;
pub type gtl_dense_hash_set_reference = u8;
pub type gtl_dense_hash_set_const_reference = u8;
pub type gtl_dense_hash_set_iterator = u8;
pub type gtl_dense_hash_set_const_iterator = u8;
pub type gtl_dense_hash_set_local_iterator = u8;
pub type gtl_dense_hash_set_const_local_iterator = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct S2ClippedShape {
    pub shape_id_: int32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: S2ClippedShape__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union S2ClippedShape__bindgen_ty_1 {
    pub edges_: *mut int32,
    pub inline_edges_: [u32; 2usize],
}
extern "C" {
    #[link_name = "\u{1}_ZNK14S2ClippedShape8shape_idEv"]
    pub fn S2ClippedShape_shape_id(this: *const S2ClippedShape) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14S2ClippedShape15contains_centerEv"]
    pub fn S2ClippedShape_contains_center(this: *const S2ClippedShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14S2ClippedShape9num_edgesEv"]
    pub fn S2ClippedShape_num_edges(this: *const S2ClippedShape) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14S2ClippedShape4edgeEi"]
    pub fn S2ClippedShape_edge(
        this: *const S2ClippedShape,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14S2ClippedShape12ContainsEdgeEi"]
    pub fn S2ClippedShape_ContainsEdge(
        this: *const S2ClippedShape,
        id: ::std::os::raw::c_int,
    ) -> bool;
}
impl S2ClippedShape {
    #[inline]
    pub fn contains_center_(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_contains_center_(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_edges_(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_num_edges_(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        contains_center_: uint32,
        num_edges_: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let contains_center_: u32 = unsafe { ::std::mem::transmute(contains_center_) };
            contains_center_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let num_edges_: u32 = unsafe { ::std::mem::transmute(num_edges_) };
            num_edges_ as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn shape_id(&self) -> ::std::os::raw::c_int {
        S2ClippedShape_shape_id(self)
    }
    #[inline]
    pub unsafe fn contains_center(&self) -> bool {
        S2ClippedShape_contains_center(self)
    }
    #[inline]
    pub unsafe fn num_edges(&self) -> ::std::os::raw::c_int {
        S2ClippedShape_num_edges(self)
    }
    #[inline]
    pub unsafe fn edge(&self, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        S2ClippedShape_edge(self, i)
    }
    #[inline]
    pub unsafe fn ContainsEdge(&self, id: ::std::os::raw::c_int) -> bool {
        S2ClippedShape_ContainsEdge(self, id)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2ShapeIndexCell {
    pub shapes_: S2ShapeIndexCell_S2ClippedShapeSet,
}
pub type S2ShapeIndexCell_S2ClippedShapeSet = [u64; 2usize];
extern "C" {
    #[link_name = "\u{1}_ZNK16S2ShapeIndexCell12find_clippedEPK7S2Shape"]
    pub fn S2ShapeIndexCell_find_clipped(
        this: *const S2ShapeIndexCell,
        shape: *const S2Shape,
    ) -> *const S2ClippedShape;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16S2ShapeIndexCell12find_clippedEi"]
    pub fn S2ShapeIndexCell_find_clipped1(
        this: *const S2ShapeIndexCell,
        shape_id: ::std::os::raw::c_int,
    ) -> *const S2ClippedShape;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16S2ShapeIndexCell9num_edgesEv"]
    pub fn S2ShapeIndexCell_num_edges(this: *const S2ShapeIndexCell) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16S2ShapeIndexCell6EncodeEiP7Encoder"]
    pub fn S2ShapeIndexCell_Encode(
        this: *const S2ShapeIndexCell,
        num_shape_ids: ::std::os::raw::c_int,
        encoder: *mut Encoder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16S2ShapeIndexCell6DecodeEiP7Decoder"]
    pub fn S2ShapeIndexCell_Decode(
        this: *mut S2ShapeIndexCell,
        num_shape_ids: ::std::os::raw::c_int,
        decoder: *mut Decoder,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16S2ShapeIndexCellD1Ev"]
    pub fn S2ShapeIndexCell_S2ShapeIndexCell_destructor(this: *mut S2ShapeIndexCell);
}
impl S2ShapeIndexCell {
    #[inline]
    pub unsafe fn find_clipped(&self, shape: *const S2Shape) -> *const S2ClippedShape {
        S2ShapeIndexCell_find_clipped(self, shape)
    }
    #[inline]
    pub unsafe fn find_clipped1(&self, shape_id: ::std::os::raw::c_int) -> *const S2ClippedShape {
        S2ShapeIndexCell_find_clipped1(self, shape_id)
    }
    #[inline]
    pub unsafe fn num_edges(&self) -> ::std::os::raw::c_int {
        S2ShapeIndexCell_num_edges(self)
    }
    #[inline]
    pub unsafe fn Encode(&self, num_shape_ids: ::std::os::raw::c_int, encoder: *mut Encoder) {
        S2ShapeIndexCell_Encode(self, num_shape_ids, encoder)
    }
    #[inline]
    pub unsafe fn Decode(
        &mut self,
        num_shape_ids: ::std::os::raw::c_int,
        decoder: *mut Decoder,
    ) -> bool {
        S2ShapeIndexCell_Decode(self, num_shape_ids, decoder)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        S2ShapeIndexCell_S2ShapeIndexCell_destructor(self)
    }
}
#[repr(C)]
pub struct S2ShapeIndex__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct S2ShapeIndex {
    pub vtable_: *const S2ShapeIndex__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2ShapeIndex_ShapeIterator {
    pub _base: u8,
    pub index_: *const S2ShapeIndex,
    pub shape_id_: ::std::os::raw::c_int,
}
pub const S2ShapeIndex_CellRelation_INDEXED: S2ShapeIndex_CellRelation = 0;
pub const S2ShapeIndex_CellRelation_SUBDIVIDED: S2ShapeIndex_CellRelation = 1;
pub const S2ShapeIndex_CellRelation_DISJOINT: S2ShapeIndex_CellRelation = 2;
pub type S2ShapeIndex_CellRelation = ::std::os::raw::c_uint;
pub const S2ShapeIndex_InitialPosition_BEGIN: S2ShapeIndex_InitialPosition = 0;
pub const S2ShapeIndex_InitialPosition_END: S2ShapeIndex_InitialPosition = 1;
pub const S2ShapeIndex_InitialPosition_UNPOSITIONED: S2ShapeIndex_InitialPosition = 2;
pub type S2ShapeIndex_InitialPosition = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct S2ShapeIndex_Iterator {
    pub iter_: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2ShapeIndex8IteratorC1ERKS0_"]
    pub fn S2ShapeIndex_Iterator_Iterator(
        this: *mut S2ShapeIndex_Iterator,
        arg1: *const S2ShapeIndex_Iterator,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2ShapeIndex8IteratorC1EOS0_"]
    pub fn S2ShapeIndex_Iterator_Iterator1(
        this: *mut S2ShapeIndex_Iterator,
        arg1: *mut S2ShapeIndex_Iterator,
    );
}
impl S2ShapeIndex_Iterator {
    #[inline]
    pub unsafe fn new(arg1: *const S2ShapeIndex_Iterator) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ShapeIndex_Iterator_Iterator(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *mut S2ShapeIndex_Iterator) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ShapeIndex_Iterator_Iterator1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct S2ShapeIndex_ShapeFactory__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct S2ShapeIndex_ShapeFactory {
    pub vtable_: *const S2ShapeIndex_ShapeFactory__bindgen_vtable,
}
#[repr(C)]
pub struct S2ShapeIndex_IteratorBase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct S2ShapeIndex_IteratorBase {
    pub vtable_: *const S2ShapeIndex_IteratorBase__bindgen_vtable,
    pub id_: S2CellId,
    pub cell_: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2ShapeIndex12IteratorBase2idEv"]
    pub fn S2ShapeIndex_IteratorBase_id(this: *const S2ShapeIndex_IteratorBase) -> S2CellId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2ShapeIndex12IteratorBase6centerEv"]
    pub fn S2ShapeIndex_IteratorBase_center(this: *const S2ShapeIndex_IteratorBase) -> S2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2ShapeIndex12IteratorBase4cellEv"]
    pub fn S2ShapeIndex_IteratorBase_cell(
        this: *const S2ShapeIndex_IteratorBase,
    ) -> *const S2ShapeIndexCell;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2ShapeIndex12IteratorBase4doneEv"]
    pub fn S2ShapeIndex_IteratorBase_done(this: *const S2ShapeIndex_IteratorBase) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2ShapeIndex12IteratorBase9set_stateE8S2CellIdPK16S2ShapeIndexCell"]
    pub fn S2ShapeIndex_IteratorBase_set_state(
        this: *mut S2ShapeIndex_IteratorBase,
        id: S2CellId,
        cell: *const S2ShapeIndexCell,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2ShapeIndex12IteratorBase12set_finishedEv"]
    pub fn S2ShapeIndex_IteratorBase_set_finished(this: *mut S2ShapeIndex_IteratorBase);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2ShapeIndex12IteratorBase8raw_cellEv"]
    pub fn S2ShapeIndex_IteratorBase_raw_cell(
        this: *const S2ShapeIndex_IteratorBase,
    ) -> *const S2ShapeIndexCell;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2ShapeIndex12IteratorBaseC2ERKS0_"]
    pub fn S2ShapeIndex_IteratorBase_IteratorBase(
        this: *mut S2ShapeIndex_IteratorBase,
        arg1: *const S2ShapeIndex_IteratorBase,
    );
}
impl S2ShapeIndex_IteratorBase {
    #[inline]
    pub unsafe fn id(&self) -> S2CellId {
        S2ShapeIndex_IteratorBase_id(self)
    }
    #[inline]
    pub unsafe fn center(&self) -> S2Point {
        S2ShapeIndex_IteratorBase_center(self)
    }
    #[inline]
    pub unsafe fn cell(&self) -> *const S2ShapeIndexCell {
        S2ShapeIndex_IteratorBase_cell(self)
    }
    #[inline]
    pub unsafe fn done(&self) -> bool {
        S2ShapeIndex_IteratorBase_done(self)
    }
    #[inline]
    pub unsafe fn set_state(&mut self, id: S2CellId, cell: *const S2ShapeIndexCell) {
        S2ShapeIndex_IteratorBase_set_state(self, id, cell)
    }
    #[inline]
    pub unsafe fn set_finished(&mut self) {
        S2ShapeIndex_IteratorBase_set_finished(self)
    }
    #[inline]
    pub unsafe fn raw_cell(&self) -> *const S2ShapeIndexCell {
        S2ShapeIndex_IteratorBase_raw_cell(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const S2ShapeIndex_IteratorBase) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ShapeIndex_IteratorBase_IteratorBase(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2ShapeIndex5beginEv"]
    pub fn S2ShapeIndex_begin(this: *const S2ShapeIndex) -> S2ShapeIndex_ShapeIterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2ShapeIndex3endEv"]
    pub fn S2ShapeIndex_end(this: *const S2ShapeIndex) -> S2ShapeIndex_ShapeIterator;
}
impl S2ShapeIndex {
    #[inline]
    pub unsafe fn begin(&self) -> S2ShapeIndex_ShapeIterator {
        S2ShapeIndex_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> S2ShapeIndex_ShapeIterator {
        S2ShapeIndex_end(self)
    }
}
#[repr(C)]
pub struct S2DistanceTarget__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct S2DistanceTarget {
    pub vtable_: *const S2DistanceTarget__bindgen_vtable,
}
pub type S2DistanceTarget_Delta = [u8; 0usize];
pub type S2DistanceTarget_ShapeVisitor = u8;
#[repr(C)]
#[derive(Debug)]
pub struct S2RegionCoverer {
    pub options_: S2RegionCoverer_Options,
    pub region_: *const S2Region,
    pub result_: [u64; 3usize],
    pub pq_: S2RegionCoverer_CandidateQueue,
    pub interior_covering_: bool,
    pub candidates_created_counter_: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2RegionCoverer_Options {
    pub max_cells_: ::std::os::raw::c_int,
    pub min_level_: ::std::os::raw::c_int,
    pub max_level_: ::std::os::raw::c_int,
    pub level_mod_: ::std::os::raw::c_int,
}
pub const S2RegionCoverer_Options_kDefaultMaxCells: ::std::os::raw::c_int = 8;
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer7Options13set_max_cellsEi"]
    pub fn S2RegionCoverer_Options_set_max_cells(
        this: *mut S2RegionCoverer_Options,
        max_cells: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer7Options13set_min_levelEi"]
    pub fn S2RegionCoverer_Options_set_min_level(
        this: *mut S2RegionCoverer_Options,
        min_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer7Options13set_max_levelEi"]
    pub fn S2RegionCoverer_Options_set_max_level(
        this: *mut S2RegionCoverer_Options,
        max_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer7Options15set_fixed_levelEi"]
    pub fn S2RegionCoverer_Options_set_fixed_level(
        this: *mut S2RegionCoverer_Options,
        level: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer7Options13set_level_modEi"]
    pub fn S2RegionCoverer_Options_set_level_mod(
        this: *mut S2RegionCoverer_Options,
        level_mod: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15S2RegionCoverer7Options14true_max_levelEv"]
    pub fn S2RegionCoverer_Options_true_max_level(
        this: *const S2RegionCoverer_Options,
    ) -> ::std::os::raw::c_int;
}
impl S2RegionCoverer_Options {
    #[inline]
    pub unsafe fn set_max_cells(&mut self, max_cells: ::std::os::raw::c_int) {
        S2RegionCoverer_Options_set_max_cells(self, max_cells)
    }
    #[inline]
    pub unsafe fn set_min_level(&mut self, min_level: ::std::os::raw::c_int) {
        S2RegionCoverer_Options_set_min_level(self, min_level)
    }
    #[inline]
    pub unsafe fn set_max_level(&mut self, max_level: ::std::os::raw::c_int) {
        S2RegionCoverer_Options_set_max_level(self, max_level)
    }
    #[inline]
    pub unsafe fn set_fixed_level(&mut self, level: ::std::os::raw::c_int) {
        S2RegionCoverer_Options_set_fixed_level(self, level)
    }
    #[inline]
    pub unsafe fn set_level_mod(&mut self, level_mod: ::std::os::raw::c_int) {
        S2RegionCoverer_Options_set_level_mod(self, level_mod)
    }
    #[inline]
    pub unsafe fn true_max_level(&self) -> ::std::os::raw::c_int {
        S2RegionCoverer_Options_true_max_level(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2RegionCoverer_Candidate {
    pub cell: S2Cell,
    pub is_terminal: bool,
    pub num_children: ::std::os::raw::c_int,
    pub children: __IncompleteArrayField<*mut S2RegionCoverer_Candidate>,
}
pub type S2RegionCoverer_QueueEntry = [u64; 2usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2RegionCoverer_CompareQueueEntries {
    pub _address: u8,
}
pub type S2RegionCoverer_CandidateQueue = [u64; 4usize];
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer11GetCoveringERK8S2Region"]
    pub fn S2RegionCoverer_GetCovering(
        this: *mut S2RegionCoverer,
        region: *const S2Region,
    ) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer19GetInteriorCoveringERK8S2Region"]
    pub fn S2RegionCoverer_GetInteriorCovering(
        this: *mut S2RegionCoverer,
        region: *const S2Region,
    ) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer11GetCoveringERK8S2RegionPSt6vectorI8S2CellIdSaIS4_EE"]
    pub fn S2RegionCoverer_GetCovering1(
        this: *mut S2RegionCoverer,
        region: *const S2Region,
        covering: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer19GetInteriorCoveringERK8S2RegionPSt6vectorI8S2CellIdSaIS4_EE"]
    pub fn S2RegionCoverer_GetInteriorCovering1(
        this: *mut S2RegionCoverer,
        region: *const S2Region,
        interior: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer15GetFastCoveringERK8S2RegionPSt6vectorI8S2CellIdSaIS4_EE"]
    pub fn S2RegionCoverer_GetFastCovering(
        this: *mut S2RegionCoverer,
        region: *const S2Region,
        covering: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer17GetSimpleCoveringERK8S2RegionRK7Vector3IdEiPSt6vectorI8S2CellIdSaIS8_EE"]
    pub fn S2RegionCoverer_GetSimpleCovering(
        region: *const S2Region,
        start: *const S2Point,
        level: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer9FloodFillERK8S2Region8S2CellIdPSt6vectorIS3_SaIS3_EE"]
    pub fn S2RegionCoverer_FloodFill(
        region: *const S2Region,
        start: S2CellId,
        output: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15S2RegionCoverer11IsCanonicalERK11S2CellUnion"]
    pub fn S2RegionCoverer_IsCanonical(
        this: *const S2RegionCoverer,
        covering: *const S2CellUnion,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15S2RegionCoverer11IsCanonicalERKSt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2RegionCoverer_IsCanonical1(
        this: *const S2RegionCoverer,
        covering: *const [u64; 3usize],
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer20CanonicalizeCoveringERK11S2CellUnion"]
    pub fn S2RegionCoverer_CanonicalizeCovering(
        this: *mut S2RegionCoverer,
        covering: *const S2CellUnion,
    ) -> S2CellUnion;
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCoverer20CanonicalizeCoveringEPSt6vectorI8S2CellIdSaIS1_EE"]
    pub fn S2RegionCoverer_CanonicalizeCovering1(
        this: *mut S2RegionCoverer,
        covering: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCovererC1ERKNS_7OptionsE"]
    pub fn S2RegionCoverer_S2RegionCoverer(
        this: *mut S2RegionCoverer,
        options: *const S2RegionCoverer_Options,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCovererC1EOS_"]
    pub fn S2RegionCoverer_S2RegionCoverer1(this: *mut S2RegionCoverer, arg1: *mut S2RegionCoverer);
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCovererC1Ev"]
    pub fn S2RegionCoverer_S2RegionCoverer2(this: *mut S2RegionCoverer);
}
extern "C" {
    #[link_name = "\u{1}_ZN15S2RegionCovererD1Ev"]
    pub fn S2RegionCoverer_S2RegionCoverer_destructor(this: *mut S2RegionCoverer);
}
impl S2RegionCoverer {
    #[inline]
    pub unsafe fn GetCovering(&mut self, region: *const S2Region) -> S2CellUnion {
        S2RegionCoverer_GetCovering(self, region)
    }
    #[inline]
    pub unsafe fn GetInteriorCovering(&mut self, region: *const S2Region) -> S2CellUnion {
        S2RegionCoverer_GetInteriorCovering(self, region)
    }
    #[inline]
    pub unsafe fn GetCovering1(&mut self, region: *const S2Region, covering: *mut [u64; 3usize]) {
        S2RegionCoverer_GetCovering1(self, region, covering)
    }
    #[inline]
    pub unsafe fn GetInteriorCovering1(
        &mut self,
        region: *const S2Region,
        interior: *mut [u64; 3usize],
    ) {
        S2RegionCoverer_GetInteriorCovering1(self, region, interior)
    }
    #[inline]
    pub unsafe fn GetFastCovering(
        &mut self,
        region: *const S2Region,
        covering: *mut [u64; 3usize],
    ) {
        S2RegionCoverer_GetFastCovering(self, region, covering)
    }
    #[inline]
    pub unsafe fn GetSimpleCovering(
        region: *const S2Region,
        start: *const S2Point,
        level: ::std::os::raw::c_int,
        output: *mut [u64; 3usize],
    ) {
        S2RegionCoverer_GetSimpleCovering(region, start, level, output)
    }
    #[inline]
    pub unsafe fn FloodFill(region: *const S2Region, start: S2CellId, output: *mut [u64; 3usize]) {
        S2RegionCoverer_FloodFill(region, start, output)
    }
    #[inline]
    pub unsafe fn IsCanonical(&self, covering: *const S2CellUnion) -> bool {
        S2RegionCoverer_IsCanonical(self, covering)
    }
    #[inline]
    pub unsafe fn IsCanonical1(&self, covering: *const [u64; 3usize]) -> bool {
        S2RegionCoverer_IsCanonical1(self, covering)
    }
    #[inline]
    pub unsafe fn CanonicalizeCovering(&mut self, covering: *const S2CellUnion) -> S2CellUnion {
        S2RegionCoverer_CanonicalizeCovering(self, covering)
    }
    #[inline]
    pub unsafe fn CanonicalizeCovering1(&mut self, covering: *mut [u64; 3usize]) {
        S2RegionCoverer_CanonicalizeCovering1(self, covering)
    }
    #[inline]
    pub unsafe fn new(options: *const S2RegionCoverer_Options) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2RegionCoverer_S2RegionCoverer(__bindgen_tmp.as_mut_ptr(), options);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *mut S2RegionCoverer) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2RegionCoverer_S2RegionCoverer1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2RegionCoverer_S2RegionCoverer2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        S2RegionCoverer_S2RegionCoverer_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2ClosestCellQueryBase<Distance> {
    pub index_: *const S2CellIndex,
    pub options_: *const S2ClosestCellQueryBase_Options<Distance>,
    pub target_: *mut S2ClosestCellQueryBase_Target,
    pub use_conservative_cell_distance_: bool,
    pub index_covering_: [u64; 3usize],
    pub distance_limit_: Distance,
    pub result_singleton_: S2ClosestCellQueryBase_Result<Distance>,
    pub result_vector_: u8,
    pub result_set_: u8,
    pub avoid_duplicates_: bool,
    pub tested_cells_: u8,
    pub queue_: S2ClosestCellQueryBase_CellQueue,
    pub contents_it_: S2CellIndex_ContentsIterator,
    pub max_distance_covering_: [u64; 3usize],
    pub intersection_with_max_distance_: [u64; 3usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
}
pub type S2ClosestCellQueryBase_Delta = [u8; 0usize];
pub type S2ClosestCellQueryBase_Label = S2CellIndex_Label;
pub type S2ClosestCellQueryBase_LabelledCell = S2CellIndex_LabelledCell;
#[repr(C)]
pub struct S2ClosestCellQueryBase_Options<Distance> {
    pub max_distance_: Distance,
    pub max_error_: S2ClosestCellQueryBase_Delta,
    pub region_: *const S2Region,
    pub max_results_: ::std::os::raw::c_int,
    pub use_brute_force_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
}
pub type S2ClosestCellQueryBase_Target = S2DistanceTarget;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2ClosestCellQueryBase_Result<Distance> {
    pub distance_: Distance,
    pub cell_id_: S2CellId,
    pub label_: S2ClosestCellQueryBase_Label,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
}
pub type S2ClosestCellQueryBase_Result_absl_btree_prefer_linear_node_search = std_true_type;
pub type S2ClosestCellQueryBase_CellIterator = S2CellIndex_CellIterator;
pub type S2ClosestCellQueryBase_ContentsIterator = S2CellIndex_ContentsIterator;
pub type S2ClosestCellQueryBase_NonEmptyRangeIterator = S2CellIndex_NonEmptyRangeIterator;
pub type S2ClosestCellQueryBase_RangeIterator = S2CellIndex_RangeIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2ClosestCellQueryBase_LabelledCellHash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2ClosestCellQueryBase_QueueEntry<Distance> {
    pub distance: Distance,
    pub id: S2CellId,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
}
pub type S2ClosestCellQueryBase_CellQueue = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S1Interval {
    pub bounds_: Vector2_d,
}
pub const S1Interval_ArgsChecked_ARGS_CHECKED: S1Interval_ArgsChecked = 0;
pub type S1Interval_ArgsChecked = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN10S1Interval5EmptyEv"]
    pub fn S1Interval_Empty() -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1Interval4FullEv"]
    pub fn S1Interval_Full() -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1Interval9FromPointEd"]
    pub fn S1Interval_FromPoint(p: f64) -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1Interval13FromPointPairEdd"]
    pub fn S1Interval_FromPointPair(p1: f64, p2: f64) -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval8is_validEv"]
    pub fn S1Interval_is_valid(this: *const S1Interval) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval9GetCenterEv"]
    pub fn S1Interval_GetCenter(this: *const S1Interval) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval9GetLengthEv"]
    pub fn S1Interval_GetLength(this: *const S1Interval) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval10ComplementEv"]
    pub fn S1Interval_Complement(this: *const S1Interval) -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval19GetComplementCenterEv"]
    pub fn S1Interval_GetComplementCenter(this: *const S1Interval) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval8ContainsEd"]
    pub fn S1Interval_Contains(this: *const S1Interval, p: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval16InteriorContainsEd"]
    pub fn S1Interval_InteriorContains(this: *const S1Interval, p: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval8ContainsERKS_"]
    pub fn S1Interval_Contains1(this: *const S1Interval, y: *const S1Interval) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval16InteriorContainsERKS_"]
    pub fn S1Interval_InteriorContains1(this: *const S1Interval, y: *const S1Interval) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval10IntersectsERKS_"]
    pub fn S1Interval_Intersects(this: *const S1Interval, y: *const S1Interval) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval18InteriorIntersectsERKS_"]
    pub fn S1Interval_InteriorIntersects(this: *const S1Interval, y: *const S1Interval) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval28GetDirectedHausdorffDistanceERKS_"]
    pub fn S1Interval_GetDirectedHausdorffDistance(
        this: *const S1Interval,
        y: *const S1Interval,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1Interval8AddPointEd"]
    pub fn S1Interval_AddPoint(this: *mut S1Interval, p: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval7ProjectEd"]
    pub fn S1Interval_Project(this: *const S1Interval, p: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval8ExpandedEd"]
    pub fn S1Interval_Expanded(this: *const S1Interval, margin: f64) -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval5UnionERKS_"]
    pub fn S1Interval_Union(this: *const S1Interval, y: *const S1Interval) -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval12IntersectionERKS_"]
    pub fn S1Interval_Intersection(this: *const S1Interval, y: *const S1Interval) -> S1Interval;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10S1Interval12ApproxEqualsERKS_d"]
    pub fn S1Interval_ApproxEquals(
        this: *const S1Interval,
        y: *const S1Interval,
        max_error: f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1Interval6set_loEd"]
    pub fn S1Interval_set_lo(this: *mut S1Interval, p: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1Interval6set_hiEd"]
    pub fn S1Interval_set_hi(this: *mut S1Interval, p: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1IntervalC1Edd"]
    pub fn S1Interval_S1Interval(this: *mut S1Interval, lo: f64, hi: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN10S1IntervalC1Ev"]
    pub fn S1Interval_S1Interval1(this: *mut S1Interval);
}
impl S1Interval {
    #[inline]
    pub unsafe fn Empty() -> S1Interval {
        S1Interval_Empty()
    }
    #[inline]
    pub unsafe fn Full() -> S1Interval {
        S1Interval_Full()
    }
    #[inline]
    pub unsafe fn FromPoint(p: f64) -> S1Interval {
        S1Interval_FromPoint(p)
    }
    #[inline]
    pub unsafe fn FromPointPair(p1: f64, p2: f64) -> S1Interval {
        S1Interval_FromPointPair(p1, p2)
    }
    #[inline]
    pub unsafe fn is_valid(&self) -> bool {
        S1Interval_is_valid(self)
    }
    #[inline]
    pub unsafe fn GetCenter(&self) -> f64 {
        S1Interval_GetCenter(self)
    }
    #[inline]
    pub unsafe fn GetLength(&self) -> f64 {
        S1Interval_GetLength(self)
    }
    #[inline]
    pub unsafe fn Complement(&self) -> S1Interval {
        S1Interval_Complement(self)
    }
    #[inline]
    pub unsafe fn GetComplementCenter(&self) -> f64 {
        S1Interval_GetComplementCenter(self)
    }
    #[inline]
    pub unsafe fn Contains(&self, p: f64) -> bool {
        S1Interval_Contains(self, p)
    }
    #[inline]
    pub unsafe fn InteriorContains(&self, p: f64) -> bool {
        S1Interval_InteriorContains(self, p)
    }
    #[inline]
    pub unsafe fn Contains1(&self, y: *const S1Interval) -> bool {
        S1Interval_Contains1(self, y)
    }
    #[inline]
    pub unsafe fn InteriorContains1(&self, y: *const S1Interval) -> bool {
        S1Interval_InteriorContains1(self, y)
    }
    #[inline]
    pub unsafe fn Intersects(&self, y: *const S1Interval) -> bool {
        S1Interval_Intersects(self, y)
    }
    #[inline]
    pub unsafe fn InteriorIntersects(&self, y: *const S1Interval) -> bool {
        S1Interval_InteriorIntersects(self, y)
    }
    #[inline]
    pub unsafe fn GetDirectedHausdorffDistance(&self, y: *const S1Interval) -> f64 {
        S1Interval_GetDirectedHausdorffDistance(self, y)
    }
    #[inline]
    pub unsafe fn AddPoint(&mut self, p: f64) {
        S1Interval_AddPoint(self, p)
    }
    #[inline]
    pub unsafe fn Project(&self, p: f64) -> f64 {
        S1Interval_Project(self, p)
    }
    #[inline]
    pub unsafe fn Expanded(&self, margin: f64) -> S1Interval {
        S1Interval_Expanded(self, margin)
    }
    #[inline]
    pub unsafe fn Union(&self, y: *const S1Interval) -> S1Interval {
        S1Interval_Union(self, y)
    }
    #[inline]
    pub unsafe fn Intersection(&self, y: *const S1Interval) -> S1Interval {
        S1Interval_Intersection(self, y)
    }
    #[inline]
    pub unsafe fn ApproxEquals(&self, y: *const S1Interval, max_error: f64) -> bool {
        S1Interval_ApproxEquals(self, y, max_error)
    }
    #[inline]
    pub unsafe fn set_lo(&mut self, p: f64) {
        S1Interval_set_lo(self, p)
    }
    #[inline]
    pub unsafe fn set_hi(&mut self, p: f64) {
        S1Interval_set_hi(self, p)
    }
    #[inline]
    pub unsafe fn new(lo: f64, hi: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S1Interval_S1Interval(__bindgen_tmp.as_mut_ptr(), lo, hi);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S1Interval_S1Interval1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2LatLngRect {
    pub _base: S2Region,
    pub lat_: R1Interval,
    pub lng_: S1Interval,
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect14FromCenterSizeERK8S2LatLngS2_"]
    pub fn S2LatLngRect_FromCenterSize(
        center: *const S2LatLng,
        size: *const S2LatLng,
    ) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect9FromPointERK8S2LatLng"]
    pub fn S2LatLngRect_FromPoint(p: *const S2LatLng) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect13FromPointPairERK8S2LatLngS2_"]
    pub fn S2LatLngRect_FromPointPair(p1: *const S2LatLng, p2: *const S2LatLng) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect5EmptyEv"]
    pub fn S2LatLngRect_Empty() -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect4FullEv"]
    pub fn S2LatLngRect_Full() -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8is_validEv"]
    pub fn S2LatLngRect_is_valid(this: *const S2LatLngRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8is_emptyEv"]
    pub fn S2LatLngRect_is_empty(this: *const S2LatLngRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect7is_fullEv"]
    pub fn S2LatLngRect_is_full(this: *const S2LatLngRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8is_pointEv"]
    pub fn S2LatLngRect_is_point(this: *const S2LatLngRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect9GetVertexEi"]
    pub fn S2LatLngRect_GetVertex(this: *const S2LatLngRect, k: ::std::os::raw::c_int) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect9GetCenterEv"]
    pub fn S2LatLngRect_GetCenter(this: *const S2LatLngRect) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect7GetSizeEv"]
    pub fn S2LatLngRect_GetSize(this: *const S2LatLngRect) -> S2LatLng;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect4AreaEv"]
    pub fn S2LatLngRect_Area(this: *const S2LatLngRect) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect11GetCentroidEv"]
    pub fn S2LatLngRect_GetCentroid(this: *const S2LatLngRect) -> S2Point;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8ContainsERK8S2LatLng"]
    pub fn S2LatLngRect_Contains(this: *const S2LatLngRect, ll: *const S2LatLng) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect16InteriorContainsERK7Vector3IdE"]
    pub fn S2LatLngRect_InteriorContains(this: *const S2LatLngRect, p: *const S2Point) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect16InteriorContainsERK8S2LatLng"]
    pub fn S2LatLngRect_InteriorContains1(this: *const S2LatLngRect, ll: *const S2LatLng) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8ContainsERKS_"]
    pub fn S2LatLngRect_Contains1(this: *const S2LatLngRect, other: *const S2LatLngRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect16InteriorContainsERKS_"]
    pub fn S2LatLngRect_InteriorContains2(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect10IntersectsERKS_"]
    pub fn S2LatLngRect_Intersects(this: *const S2LatLngRect, other: *const S2LatLngRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect10IntersectsERK6S2Cell"]
    pub fn S2LatLngRect_Intersects1(this: *const S2LatLngRect, cell: *const S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect18InteriorIntersectsERKS_"]
    pub fn S2LatLngRect_InteriorIntersects(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect18BoundaryIntersectsERK7Vector3IdES3_"]
    pub fn S2LatLngRect_BoundaryIntersects(
        this: *const S2LatLngRect,
        v0: *const S2Point,
        v1: *const S2Point,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect8AddPointERK7Vector3IdE"]
    pub fn S2LatLngRect_AddPoint(this: *mut S2LatLngRect, p: *const S2Point);
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect8AddPointERK8S2LatLng"]
    pub fn S2LatLngRect_AddPoint1(this: *mut S2LatLngRect, ll: *const S2LatLng);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8ExpandedERK8S2LatLng"]
    pub fn S2LatLngRect_Expanded(
        this: *const S2LatLngRect,
        margin: *const S2LatLng,
    ) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect12PolarClosureEv"]
    pub fn S2LatLngRect_PolarClosure(this: *const S2LatLngRect) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect5UnionERKS_"]
    pub fn S2LatLngRect_Union(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
    ) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect12IntersectionERKS_"]
    pub fn S2LatLngRect_Intersection(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
    ) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect18ExpandedByDistanceE7S1Angle"]
    pub fn S2LatLngRect_ExpandedByDistance(
        this: *const S2LatLngRect,
        distance: S1Angle,
    ) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect11GetDistanceERKS_"]
    pub fn S2LatLngRect_GetDistance(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
    ) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect11GetDistanceERK8S2LatLng"]
    pub fn S2LatLngRect_GetDistance1(this: *const S2LatLngRect, p: *const S2LatLng) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect28GetDirectedHausdorffDistanceERKS_"]
    pub fn S2LatLngRect_GetDirectedHausdorffDistance(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
    ) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect20GetHausdorffDistanceERKS_"]
    pub fn S2LatLngRect_GetHausdorffDistance(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
    ) -> S1Angle;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect12ApproxEqualsERKS_7S1Angle"]
    pub fn S2LatLngRect_ApproxEquals(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
        max_error: S1Angle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect12ApproxEqualsERKS_RK8S2LatLng"]
    pub fn S2LatLngRect_ApproxEquals1(
        this: *const S2LatLngRect,
        other: *const S2LatLngRect,
        max_error: *const S2LatLng,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect6EncodeEP7Encoder"]
    pub fn S2LatLngRect_Encode(this: *const S2LatLngRect, encoder: *mut Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect6DecodeEP7Decoder"]
    pub fn S2LatLngRect_Decode(this: *mut S2LatLngRect, decoder: *mut Decoder) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect17IntersectsLngEdgeERK7Vector3IdES3_RK10R1Intervald"]
    pub fn S2LatLngRect_IntersectsLngEdge(
        a: *const S2Point,
        b: *const S2Point,
        lat: *const R1Interval,
        lng: f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRect17IntersectsLatEdgeERK7Vector3IdES3_dRK10S1Interval"]
    pub fn S2LatLngRect_IntersectsLatEdge(
        a: *const S2Point,
        b: *const S2Point,
        lat: f64,
        lng: *const S1Interval,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRectC1ERK8S2LatLngS2_"]
    pub fn S2LatLngRect_S2LatLngRect(
        this: *mut S2LatLngRect,
        lo: *const S2LatLng,
        hi: *const S2LatLng,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRectC1ERK10R1IntervalRK10S1Interval"]
    pub fn S2LatLngRect_S2LatLngRect1(
        this: *mut S2LatLngRect,
        lat: *const R1Interval,
        lng: *const S1Interval,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12S2LatLngRectC1Ev"]
    pub fn S2LatLngRect_S2LatLngRect2(this: *mut S2LatLngRect);
}
impl S2LatLngRect {
    #[inline]
    pub unsafe fn FromCenterSize(center: *const S2LatLng, size: *const S2LatLng) -> S2LatLngRect {
        S2LatLngRect_FromCenterSize(center, size)
    }
    #[inline]
    pub unsafe fn FromPoint(p: *const S2LatLng) -> S2LatLngRect {
        S2LatLngRect_FromPoint(p)
    }
    #[inline]
    pub unsafe fn FromPointPair(p1: *const S2LatLng, p2: *const S2LatLng) -> S2LatLngRect {
        S2LatLngRect_FromPointPair(p1, p2)
    }
    #[inline]
    pub unsafe fn Empty() -> S2LatLngRect {
        S2LatLngRect_Empty()
    }
    #[inline]
    pub unsafe fn Full() -> S2LatLngRect {
        S2LatLngRect_Full()
    }
    #[inline]
    pub unsafe fn is_valid(&self) -> bool {
        S2LatLngRect_is_valid(self)
    }
    #[inline]
    pub unsafe fn is_empty(&self) -> bool {
        S2LatLngRect_is_empty(self)
    }
    #[inline]
    pub unsafe fn is_full(&self) -> bool {
        S2LatLngRect_is_full(self)
    }
    #[inline]
    pub unsafe fn is_point(&self) -> bool {
        S2LatLngRect_is_point(self)
    }
    #[inline]
    pub unsafe fn GetVertex(&self, k: ::std::os::raw::c_int) -> S2LatLng {
        S2LatLngRect_GetVertex(self, k)
    }
    #[inline]
    pub unsafe fn GetCenter(&self) -> S2LatLng {
        S2LatLngRect_GetCenter(self)
    }
    #[inline]
    pub unsafe fn GetSize(&self) -> S2LatLng {
        S2LatLngRect_GetSize(self)
    }
    #[inline]
    pub unsafe fn Area(&self) -> f64 {
        S2LatLngRect_Area(self)
    }
    #[inline]
    pub unsafe fn GetCentroid(&self) -> S2Point {
        S2LatLngRect_GetCentroid(self)
    }
    #[inline]
    pub unsafe fn Contains(&self, ll: *const S2LatLng) -> bool {
        S2LatLngRect_Contains(self, ll)
    }
    #[inline]
    pub unsafe fn InteriorContains(&self, p: *const S2Point) -> bool {
        S2LatLngRect_InteriorContains(self, p)
    }
    #[inline]
    pub unsafe fn InteriorContains1(&self, ll: *const S2LatLng) -> bool {
        S2LatLngRect_InteriorContains1(self, ll)
    }
    #[inline]
    pub unsafe fn Contains1(&self, other: *const S2LatLngRect) -> bool {
        S2LatLngRect_Contains1(self, other)
    }
    #[inline]
    pub unsafe fn InteriorContains2(&self, other: *const S2LatLngRect) -> bool {
        S2LatLngRect_InteriorContains2(self, other)
    }
    #[inline]
    pub unsafe fn Intersects(&self, other: *const S2LatLngRect) -> bool {
        S2LatLngRect_Intersects(self, other)
    }
    #[inline]
    pub unsafe fn Intersects1(&self, cell: *const S2Cell) -> bool {
        S2LatLngRect_Intersects1(self, cell)
    }
    #[inline]
    pub unsafe fn InteriorIntersects(&self, other: *const S2LatLngRect) -> bool {
        S2LatLngRect_InteriorIntersects(self, other)
    }
    #[inline]
    pub unsafe fn BoundaryIntersects(&self, v0: *const S2Point, v1: *const S2Point) -> bool {
        S2LatLngRect_BoundaryIntersects(self, v0, v1)
    }
    #[inline]
    pub unsafe fn AddPoint(&mut self, p: *const S2Point) {
        S2LatLngRect_AddPoint(self, p)
    }
    #[inline]
    pub unsafe fn AddPoint1(&mut self, ll: *const S2LatLng) {
        S2LatLngRect_AddPoint1(self, ll)
    }
    #[inline]
    pub unsafe fn Expanded(&self, margin: *const S2LatLng) -> S2LatLngRect {
        S2LatLngRect_Expanded(self, margin)
    }
    #[inline]
    pub unsafe fn PolarClosure(&self) -> S2LatLngRect {
        S2LatLngRect_PolarClosure(self)
    }
    #[inline]
    pub unsafe fn Union(&self, other: *const S2LatLngRect) -> S2LatLngRect {
        S2LatLngRect_Union(self, other)
    }
    #[inline]
    pub unsafe fn Intersection(&self, other: *const S2LatLngRect) -> S2LatLngRect {
        S2LatLngRect_Intersection(self, other)
    }
    #[inline]
    pub unsafe fn ExpandedByDistance(&self, distance: S1Angle) -> S2LatLngRect {
        S2LatLngRect_ExpandedByDistance(self, distance)
    }
    #[inline]
    pub unsafe fn GetDistance(&self, other: *const S2LatLngRect) -> S1Angle {
        S2LatLngRect_GetDistance(self, other)
    }
    #[inline]
    pub unsafe fn GetDistance1(&self, p: *const S2LatLng) -> S1Angle {
        S2LatLngRect_GetDistance1(self, p)
    }
    #[inline]
    pub unsafe fn GetDirectedHausdorffDistance(&self, other: *const S2LatLngRect) -> S1Angle {
        S2LatLngRect_GetDirectedHausdorffDistance(self, other)
    }
    #[inline]
    pub unsafe fn GetHausdorffDistance(&self, other: *const S2LatLngRect) -> S1Angle {
        S2LatLngRect_GetHausdorffDistance(self, other)
    }
    #[inline]
    pub unsafe fn ApproxEquals(&self, other: *const S2LatLngRect, max_error: S1Angle) -> bool {
        S2LatLngRect_ApproxEquals(self, other, max_error)
    }
    #[inline]
    pub unsafe fn ApproxEquals1(
        &self,
        other: *const S2LatLngRect,
        max_error: *const S2LatLng,
    ) -> bool {
        S2LatLngRect_ApproxEquals1(self, other, max_error)
    }
    #[inline]
    pub unsafe fn Encode(&self, encoder: *mut Encoder) {
        S2LatLngRect_Encode(self, encoder)
    }
    #[inline]
    pub unsafe fn Decode(&mut self, decoder: *mut Decoder) -> bool {
        S2LatLngRect_Decode(self, decoder)
    }
    #[inline]
    pub unsafe fn IntersectsLngEdge(
        a: *const S2Point,
        b: *const S2Point,
        lat: *const R1Interval,
        lng: f64,
    ) -> bool {
        S2LatLngRect_IntersectsLngEdge(a, b, lat, lng)
    }
    #[inline]
    pub unsafe fn IntersectsLatEdge(
        a: *const S2Point,
        b: *const S2Point,
        lat: f64,
        lng: *const S1Interval,
    ) -> bool {
        S2LatLngRect_IntersectsLatEdge(a, b, lat, lng)
    }
    #[inline]
    pub unsafe fn new(lo: *const S2LatLng, hi: *const S2LatLng) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2LatLngRect_S2LatLngRect(__bindgen_tmp.as_mut_ptr(), lo, hi);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(lat: *const R1Interval, lng: *const S1Interval) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2LatLngRect_S2LatLngRect1(__bindgen_tmp.as_mut_ptr(), lat, lng);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2LatLngRect_S2LatLngRect2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect5CloneEv"]
    pub fn S2LatLngRect_Clone(this: *mut ::std::os::raw::c_void) -> *mut S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect11GetCapBoundEv"]
    pub fn S2LatLngRect_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect12GetRectBoundEv"]
    pub fn S2LatLngRect_GetRectBound(this: *mut ::std::os::raw::c_void) -> S2LatLngRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8ContainsERK6S2Cell"]
    pub fn S2LatLngRect_Contains2(this: *mut ::std::os::raw::c_void, cell: *const S2Cell) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect12MayIntersectERK6S2Cell"]
    pub fn S2LatLngRect_MayIntersect(
        this: *mut ::std::os::raw::c_void,
        cell: *const S2Cell,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12S2LatLngRect8ContainsERK7Vector3IdE"]
    pub fn S2LatLngRect_Contains3(this: *mut ::std::os::raw::c_void, p: *const S2Point) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2ClosestEdgeQuery {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2MinDistance {
    pub _base: S1ChordAngle,
}
pub type S2MinDistance_Delta = S1ChordAngle;
extern "C" {
    #[link_name = "\u{1}_ZN13S2MinDistance4ZeroEv"]
    pub fn S2MinDistance_Zero() -> S2MinDistance;
}
extern "C" {
    #[link_name = "\u{1}_ZN13S2MinDistance8InfinityEv"]
    pub fn S2MinDistance_Infinity() -> S2MinDistance;
}
extern "C" {
    #[link_name = "\u{1}_ZN13S2MinDistance8NegativeEv"]
    pub fn S2MinDistance_Negative() -> S2MinDistance;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13S2MinDistance18GetChordAngleBoundEv"]
    pub fn S2MinDistance_GetChordAngleBound(this: *const S2MinDistance) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN13S2MinDistance9UpdateMinERKS_"]
    pub fn S2MinDistance_UpdateMin(this: *mut S2MinDistance, dist: *const S2MinDistance) -> bool;
}
impl S2MinDistance {
    #[inline]
    pub unsafe fn Zero() -> S2MinDistance {
        S2MinDistance_Zero()
    }
    #[inline]
    pub unsafe fn Infinity() -> S2MinDistance {
        S2MinDistance_Infinity()
    }
    #[inline]
    pub unsafe fn Negative() -> S2MinDistance {
        S2MinDistance_Negative()
    }
    #[inline]
    pub unsafe fn GetChordAngleBound(&self) -> S1ChordAngle {
        S2MinDistance_GetChordAngleBound(self)
    }
    #[inline]
    pub unsafe fn UpdateMin(&mut self, dist: *const S2MinDistance) -> bool {
        S2MinDistance_UpdateMin(self, dist)
    }
}
pub type S2MinDistanceTarget = S2DistanceTarget;
#[repr(C)]
#[derive(Debug)]
pub struct S2MinDistancePointTarget {
    pub _base: S2MinDistanceTarget,
    pub point_: S2Point,
}
extern "C" {
    #[link_name = "\u{1}_ZN24S2MinDistancePointTargetC1ERK7Vector3IdE"]
    pub fn S2MinDistancePointTarget_S2MinDistancePointTarget(
        this: *mut S2MinDistancePointTarget,
        point: *const S2Point,
    );
}
impl S2MinDistancePointTarget {
    #[inline]
    pub unsafe fn new(point: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2MinDistancePointTarget_S2MinDistancePointTarget(__bindgen_tmp.as_mut_ptr(), point);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN24S2MinDistancePointTarget11GetCapBoundEv"]
    pub fn S2MinDistancePointTarget_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN24S2MinDistancePointTarget17UpdateMinDistanceERK7Vector3IdEP13S2MinDistance"]
    pub fn S2MinDistancePointTarget_UpdateMinDistance(
        this: *mut ::std::os::raw::c_void,
        p: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN24S2MinDistancePointTarget17UpdateMinDistanceERK7Vector3IdES3_P13S2MinDistance"]
    pub fn S2MinDistancePointTarget_UpdateMinDistance1(
        this: *mut ::std::os::raw::c_void,
        v0: *const S2Point,
        v1: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN24S2MinDistancePointTarget17UpdateMinDistanceERK6S2CellP13S2MinDistance"]
    pub fn S2MinDistancePointTarget_UpdateMinDistance2(
        this: *mut ::std::os::raw::c_void,
        cell: *const S2Cell,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN24S2MinDistancePointTarget21VisitContainingShapesERK12S2ShapeIndexRKSt8functionIFbP7S2ShapeRK7Vector3IdEEE"]
    pub fn S2MinDistancePointTarget_VisitContainingShapes(
        this: *mut ::std::os::raw::c_void,
        index: *const S2ShapeIndex,
        visitor: *const ShapeVisitor,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2MinDistanceEdgeTarget {
    pub _base: S2MinDistanceTarget,
    pub a_: S2Point,
    pub b_: S2Point,
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceEdgeTargetC1ERK7Vector3IdES3_"]
    pub fn S2MinDistanceEdgeTarget_S2MinDistanceEdgeTarget(
        this: *mut S2MinDistanceEdgeTarget,
        a: *const S2Point,
        b: *const S2Point,
    );
}
impl S2MinDistanceEdgeTarget {
    #[inline]
    pub unsafe fn new(a: *const S2Point, b: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2MinDistanceEdgeTarget_S2MinDistanceEdgeTarget(__bindgen_tmp.as_mut_ptr(), a, b);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceEdgeTarget11GetCapBoundEv"]
    pub fn S2MinDistanceEdgeTarget_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceEdgeTarget17UpdateMinDistanceERK7Vector3IdEP13S2MinDistance"]
    pub fn S2MinDistanceEdgeTarget_UpdateMinDistance(
        this: *mut ::std::os::raw::c_void,
        p: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceEdgeTarget17UpdateMinDistanceERK7Vector3IdES3_P13S2MinDistance"]
    pub fn S2MinDistanceEdgeTarget_UpdateMinDistance1(
        this: *mut ::std::os::raw::c_void,
        v0: *const S2Point,
        v1: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceEdgeTarget17UpdateMinDistanceERK6S2CellP13S2MinDistance"]
    pub fn S2MinDistanceEdgeTarget_UpdateMinDistance2(
        this: *mut ::std::os::raw::c_void,
        cell: *const S2Cell,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceEdgeTarget21VisitContainingShapesERK12S2ShapeIndexRKSt8functionIFbP7S2ShapeRK7Vector3IdEEE"]
    pub fn S2MinDistanceEdgeTarget_VisitContainingShapes(
        this: *mut ::std::os::raw::c_void,
        index: *const S2ShapeIndex,
        visitor: *const ShapeVisitor,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2MinDistanceCellTarget {
    pub _base: S2MinDistanceTarget,
    pub cell_: S2Cell,
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceCellTargetC1ERK6S2Cell"]
    pub fn S2MinDistanceCellTarget_S2MinDistanceCellTarget(
        this: *mut S2MinDistanceCellTarget,
        cell: *const S2Cell,
    );
}
impl S2MinDistanceCellTarget {
    #[inline]
    pub unsafe fn new(cell: *const S2Cell) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2MinDistanceCellTarget_S2MinDistanceCellTarget(__bindgen_tmp.as_mut_ptr(), cell);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceCellTarget11GetCapBoundEv"]
    pub fn S2MinDistanceCellTarget_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceCellTarget17UpdateMinDistanceERK7Vector3IdEP13S2MinDistance"]
    pub fn S2MinDistanceCellTarget_UpdateMinDistance(
        this: *mut ::std::os::raw::c_void,
        p: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceCellTarget17UpdateMinDistanceERK7Vector3IdES3_P13S2MinDistance"]
    pub fn S2MinDistanceCellTarget_UpdateMinDistance1(
        this: *mut ::std::os::raw::c_void,
        v0: *const S2Point,
        v1: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceCellTarget17UpdateMinDistanceERK6S2CellP13S2MinDistance"]
    pub fn S2MinDistanceCellTarget_UpdateMinDistance2(
        this: *mut ::std::os::raw::c_void,
        cell: *const S2Cell,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23S2MinDistanceCellTarget21VisitContainingShapesERK12S2ShapeIndexRKSt8functionIFbP7S2ShapeRK7Vector3IdEEE"]
    pub fn S2MinDistanceCellTarget_VisitContainingShapes(
        this: *mut ::std::os::raw::c_void,
        index: *const S2ShapeIndex,
        visitor: *const ShapeVisitor,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2MinDistanceCellUnionTarget {
    pub _base: S2MinDistanceTarget,
    pub cell_union_: S2CellUnion,
    pub index_: S2CellIndex,
    pub query_: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZNK28S2MinDistanceCellUnionTarget15use_brute_forceEv"]
    pub fn S2MinDistanceCellUnionTarget_use_brute_force(
        this: *const S2MinDistanceCellUnionTarget,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTarget19set_use_brute_forceEb"]
    pub fn S2MinDistanceCellUnionTarget_set_use_brute_force(
        this: *mut S2MinDistanceCellUnionTarget,
        use_brute_force: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTargetC1E11S2CellUnion"]
    pub fn S2MinDistanceCellUnionTarget_S2MinDistanceCellUnionTarget(
        this: *mut S2MinDistanceCellUnionTarget,
        cell_union: S2CellUnion,
    );
}
impl S2MinDistanceCellUnionTarget {
    #[inline]
    pub unsafe fn use_brute_force(&self) -> bool {
        S2MinDistanceCellUnionTarget_use_brute_force(self)
    }
    #[inline]
    pub unsafe fn set_use_brute_force(&mut self, use_brute_force: bool) {
        S2MinDistanceCellUnionTarget_set_use_brute_force(self, use_brute_force)
    }
    #[inline]
    pub unsafe fn new(cell_union: S2CellUnion) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2MinDistanceCellUnionTarget_S2MinDistanceCellUnionTarget(
            __bindgen_tmp.as_mut_ptr(),
            cell_union,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTargetD1Ev"]
    pub fn S2MinDistanceCellUnionTarget_S2MinDistanceCellUnionTarget_destructor(
        this: *mut S2MinDistanceCellUnionTarget,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTarget13set_max_errorERK12S1ChordAngle"]
    pub fn S2MinDistanceCellUnionTarget_set_max_error(
        this: *mut ::std::os::raw::c_void,
        max_error: *const S1ChordAngle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTarget11GetCapBoundEv"]
    pub fn S2MinDistanceCellUnionTarget_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTarget17UpdateMinDistanceERK7Vector3IdEP13S2MinDistance"]
    pub fn S2MinDistanceCellUnionTarget_UpdateMinDistance(
        this: *mut ::std::os::raw::c_void,
        p: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTarget17UpdateMinDistanceERK7Vector3IdES3_P13S2MinDistance"]
    pub fn S2MinDistanceCellUnionTarget_UpdateMinDistance1(
        this: *mut ::std::os::raw::c_void,
        v0: *const S2Point,
        v1: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTarget17UpdateMinDistanceERK6S2CellP13S2MinDistance"]
    pub fn S2MinDistanceCellUnionTarget_UpdateMinDistance2(
        this: *mut ::std::os::raw::c_void,
        cell: *const S2Cell,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN28S2MinDistanceCellUnionTarget21VisitContainingShapesERK12S2ShapeIndexRKSt8functionIFbP7S2ShapeRK7Vector3IdEEE"]
    pub fn S2MinDistanceCellUnionTarget_VisitContainingShapes(
        this: *mut ::std::os::raw::c_void,
        query_index: *const S2ShapeIndex,
        visitor: *const ShapeVisitor,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2MinDistanceShapeIndexTarget {
    pub _base: S2MinDistanceTarget,
    pub index_: *const S2ShapeIndex,
    pub query_: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZNK29S2MinDistanceShapeIndexTarget17include_interiorsEv"]
    pub fn S2MinDistanceShapeIndexTarget_include_interiors(
        this: *const S2MinDistanceShapeIndexTarget,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget21set_include_interiorsEb"]
    pub fn S2MinDistanceShapeIndexTarget_set_include_interiors(
        this: *mut S2MinDistanceShapeIndexTarget,
        include_interiors: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK29S2MinDistanceShapeIndexTarget15use_brute_forceEv"]
    pub fn S2MinDistanceShapeIndexTarget_use_brute_force(
        this: *const S2MinDistanceShapeIndexTarget,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget19set_use_brute_forceEb"]
    pub fn S2MinDistanceShapeIndexTarget_set_use_brute_force(
        this: *mut S2MinDistanceShapeIndexTarget,
        use_brute_force: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTargetC1EPK12S2ShapeIndex"]
    pub fn S2MinDistanceShapeIndexTarget_S2MinDistanceShapeIndexTarget(
        this: *mut S2MinDistanceShapeIndexTarget,
        index: *const S2ShapeIndex,
    );
}
impl S2MinDistanceShapeIndexTarget {
    #[inline]
    pub unsafe fn include_interiors(&self) -> bool {
        S2MinDistanceShapeIndexTarget_include_interiors(self)
    }
    #[inline]
    pub unsafe fn set_include_interiors(&mut self, include_interiors: bool) {
        S2MinDistanceShapeIndexTarget_set_include_interiors(self, include_interiors)
    }
    #[inline]
    pub unsafe fn use_brute_force(&self) -> bool {
        S2MinDistanceShapeIndexTarget_use_brute_force(self)
    }
    #[inline]
    pub unsafe fn set_use_brute_force(&mut self, use_brute_force: bool) {
        S2MinDistanceShapeIndexTarget_set_use_brute_force(self, use_brute_force)
    }
    #[inline]
    pub unsafe fn new(index: *const S2ShapeIndex) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2MinDistanceShapeIndexTarget_S2MinDistanceShapeIndexTarget(
            __bindgen_tmp.as_mut_ptr(),
            index,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTargetD1Ev"]
    pub fn S2MinDistanceShapeIndexTarget_S2MinDistanceShapeIndexTarget_destructor(
        this: *mut S2MinDistanceShapeIndexTarget,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget13set_max_errorERK12S1ChordAngle"]
    pub fn S2MinDistanceShapeIndexTarget_set_max_error(
        this: *mut ::std::os::raw::c_void,
        max_error: *const S1ChordAngle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget11GetCapBoundEv"]
    pub fn S2MinDistanceShapeIndexTarget_GetCapBound(this: *mut ::std::os::raw::c_void) -> S2Cap;
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget17UpdateMinDistanceERK7Vector3IdEP13S2MinDistance"]
    pub fn S2MinDistanceShapeIndexTarget_UpdateMinDistance(
        this: *mut ::std::os::raw::c_void,
        p: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget17UpdateMinDistanceERK7Vector3IdES3_P13S2MinDistance"]
    pub fn S2MinDistanceShapeIndexTarget_UpdateMinDistance1(
        this: *mut ::std::os::raw::c_void,
        v0: *const S2Point,
        v1: *const S2Point,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget17UpdateMinDistanceERK6S2CellP13S2MinDistance"]
    pub fn S2MinDistanceShapeIndexTarget_UpdateMinDistance2(
        this: *mut ::std::os::raw::c_void,
        cell: *const S2Cell,
        min_dist: *mut S2MinDistance,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN29S2MinDistanceShapeIndexTarget21VisitContainingShapesERK12S2ShapeIndexRKSt8functionIFbP7S2ShapeRK7Vector3IdEEE"]
    pub fn S2MinDistanceShapeIndexTarget_VisitContainingShapes(
        this: *mut ::std::os::raw::c_void,
        query_index: *const S2ShapeIndex,
        visitor: *const ShapeVisitor,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2ClosestCellQuery {
    pub options_: S2ClosestCellQuery_Options,
    pub base_: S2ClosestCellQuery_Base,
}
pub type S2ClosestCellQuery_Distance = S2MinDistance;
pub type S2ClosestCellQuery_Base = S2ClosestCellQueryBase<S2ClosestCellQuery_Distance>;
pub type S2ClosestCellQuery_Result = Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2ClosestCellQuery_Options {
    pub _base: Options,
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery7Options16set_max_distanceE12S1ChordAngle"]
    pub fn S2ClosestCellQuery_Options_set_max_distance(
        this: *mut S2ClosestCellQuery_Options,
        max_distance: S1ChordAngle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery7Options26set_inclusive_max_distanceE12S1ChordAngle"]
    pub fn S2ClosestCellQuery_Options_set_inclusive_max_distance(
        this: *mut S2ClosestCellQuery_Options,
        max_distance: S1ChordAngle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery7Options29set_conservative_max_distanceE12S1ChordAngle"]
    pub fn S2ClosestCellQuery_Options_set_conservative_max_distance(
        this: *mut S2ClosestCellQuery_Options,
        max_distance: S1ChordAngle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery7Options16set_max_distanceE7S1Angle"]
    pub fn S2ClosestCellQuery_Options_set_max_distance1(
        this: *mut S2ClosestCellQuery_Options,
        max_distance: S1Angle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery7Options26set_inclusive_max_distanceE7S1Angle"]
    pub fn S2ClosestCellQuery_Options_set_inclusive_max_distance1(
        this: *mut S2ClosestCellQuery_Options,
        max_distance: S1Angle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery7Options29set_conservative_max_distanceE7S1Angle"]
    pub fn S2ClosestCellQuery_Options_set_conservative_max_distance1(
        this: *mut S2ClosestCellQuery_Options,
        max_distance: S1Angle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery7Options13set_max_errorE7S1Angle"]
    pub fn S2ClosestCellQuery_Options_set_max_error(
        this: *mut S2ClosestCellQuery_Options,
        max_error: S1Angle,
    );
}
impl S2ClosestCellQuery_Options {
    #[inline]
    pub unsafe fn set_max_distance(&mut self, max_distance: S1ChordAngle) {
        S2ClosestCellQuery_Options_set_max_distance(self, max_distance)
    }
    #[inline]
    pub unsafe fn set_inclusive_max_distance(&mut self, max_distance: S1ChordAngle) {
        S2ClosestCellQuery_Options_set_inclusive_max_distance(self, max_distance)
    }
    #[inline]
    pub unsafe fn set_conservative_max_distance(&mut self, max_distance: S1ChordAngle) {
        S2ClosestCellQuery_Options_set_conservative_max_distance(self, max_distance)
    }
    #[inline]
    pub unsafe fn set_max_distance1(&mut self, max_distance: S1Angle) {
        S2ClosestCellQuery_Options_set_max_distance1(self, max_distance)
    }
    #[inline]
    pub unsafe fn set_inclusive_max_distance1(&mut self, max_distance: S1Angle) {
        S2ClosestCellQuery_Options_set_inclusive_max_distance1(self, max_distance)
    }
    #[inline]
    pub unsafe fn set_conservative_max_distance1(&mut self, max_distance: S1Angle) {
        S2ClosestCellQuery_Options_set_conservative_max_distance1(self, max_distance)
    }
    #[inline]
    pub unsafe fn set_max_error(&mut self, max_error: S1Angle) {
        S2ClosestCellQuery_Options_set_max_error(self, max_error)
    }
}
pub type S2ClosestCellQuery_Target = S2MinDistanceTarget;
#[repr(C)]
#[derive(Debug)]
pub struct S2ClosestCellQuery_PointTarget {
    pub _base: S2MinDistancePointTarget,
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery11PointTargetC1ERK7Vector3IdE"]
    pub fn S2ClosestCellQuery_PointTarget_PointTarget(
        this: *mut S2ClosestCellQuery_PointTarget,
        point: *const S2Point,
    );
}
impl S2ClosestCellQuery_PointTarget {
    #[inline]
    pub unsafe fn new(point: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ClosestCellQuery_PointTarget_PointTarget(__bindgen_tmp.as_mut_ptr(), point);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2ClosestCellQuery_EdgeTarget {
    pub _base: S2MinDistanceEdgeTarget,
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery10EdgeTargetC1ERK7Vector3IdES4_"]
    pub fn S2ClosestCellQuery_EdgeTarget_EdgeTarget(
        this: *mut S2ClosestCellQuery_EdgeTarget,
        a: *const S2Point,
        b: *const S2Point,
    );
}
impl S2ClosestCellQuery_EdgeTarget {
    #[inline]
    pub unsafe fn new(a: *const S2Point, b: *const S2Point) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ClosestCellQuery_EdgeTarget_EdgeTarget(__bindgen_tmp.as_mut_ptr(), a, b);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2ClosestCellQuery_CellTarget {
    pub _base: S2MinDistanceCellTarget,
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery10CellTargetC1ERK6S2Cell"]
    pub fn S2ClosestCellQuery_CellTarget_CellTarget(
        this: *mut S2ClosestCellQuery_CellTarget,
        cell: *const S2Cell,
    );
}
impl S2ClosestCellQuery_CellTarget {
    #[inline]
    pub unsafe fn new(cell: *const S2Cell) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ClosestCellQuery_CellTarget_CellTarget(__bindgen_tmp.as_mut_ptr(), cell);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2ClosestCellQuery_CellUnionTarget {
    pub _base: S2MinDistanceCellUnionTarget,
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery15CellUnionTargetC1E11S2CellUnion"]
    pub fn S2ClosestCellQuery_CellUnionTarget_CellUnionTarget(
        this: *mut S2ClosestCellQuery_CellUnionTarget,
        cell_union: S2CellUnion,
    );
}
impl S2ClosestCellQuery_CellUnionTarget {
    #[inline]
    pub unsafe fn new(cell_union: S2CellUnion) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ClosestCellQuery_CellUnionTarget_CellUnionTarget(__bindgen_tmp.as_mut_ptr(), cell_union);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct S2ClosestCellQuery_ShapeIndexTarget {
    pub _base: S2MinDistanceShapeIndexTarget,
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery16ShapeIndexTargetC1EPK12S2ShapeIndex"]
    pub fn S2ClosestCellQuery_ShapeIndexTarget_ShapeIndexTarget(
        this: *mut S2ClosestCellQuery_ShapeIndexTarget,
        index: *const S2ShapeIndex,
    );
}
impl S2ClosestCellQuery_ShapeIndexTarget {
    #[inline]
    pub unsafe fn new(index: *const S2ShapeIndex) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ClosestCellQuery_ShapeIndexTarget_ShapeIndexTarget(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery4InitEPK11S2CellIndexRKNS_7OptionsE"]
    pub fn S2ClosestCellQuery_Init(
        this: *mut S2ClosestCellQuery,
        index: *const S2CellIndex,
        options: *const S2ClosestCellQuery_Options,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery6ReInitEv"]
    pub fn S2ClosestCellQuery_ReInit(this: *mut S2ClosestCellQuery);
}
extern "C" {
    #[link_name = "\u{1}_ZNK18S2ClosestCellQuery5indexEv"]
    pub fn S2ClosestCellQuery_index(this: *const S2ClosestCellQuery) -> *const S2CellIndex;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18S2ClosestCellQuery7optionsEv"]
    pub fn S2ClosestCellQuery_options(
        this: *const S2ClosestCellQuery,
    ) -> *const S2ClosestCellQuery_Options;
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery15mutable_optionsEv"]
    pub fn S2ClosestCellQuery_mutable_options(
        this: *mut S2ClosestCellQuery,
    ) -> *mut S2ClosestCellQuery_Options;
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery16FindClosestCellsEP16S2DistanceTargetI13S2MinDistanceE"]
    pub fn S2ClosestCellQuery_FindClosestCells(
        this: *mut S2ClosestCellQuery,
        target: *mut S2ClosestCellQuery_Target,
    ) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery16FindClosestCellsEP16S2DistanceTargetI13S2MinDistanceEPSt6vectorIN22S2ClosestCellQueryBaseIS1_E6ResultESaIS7_EE"]
    pub fn S2ClosestCellQuery_FindClosestCells1(
        this: *mut S2ClosestCellQuery,
        target: *mut S2ClosestCellQuery_Target,
        results: *mut [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery15FindClosestCellEP16S2DistanceTargetI13S2MinDistanceE"]
    pub fn S2ClosestCellQuery_FindClosestCell(
        this: *mut S2ClosestCellQuery,
        target: *mut S2ClosestCellQuery_Target,
    ) -> S2ClosestCellQuery_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery11GetDistanceEP16S2DistanceTargetI13S2MinDistanceE"]
    pub fn S2ClosestCellQuery_GetDistance(
        this: *mut S2ClosestCellQuery,
        target: *mut S2ClosestCellQuery_Target,
    ) -> S1ChordAngle;
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery14IsDistanceLessEP16S2DistanceTargetI13S2MinDistanceE12S1ChordAngle"]
    pub fn S2ClosestCellQuery_IsDistanceLess(
        this: *mut S2ClosestCellQuery,
        target: *mut S2ClosestCellQuery_Target,
        limit: S1ChordAngle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery21IsDistanceLessOrEqualEP16S2DistanceTargetI13S2MinDistanceE12S1ChordAngle"]
    pub fn S2ClosestCellQuery_IsDistanceLessOrEqual(
        this: *mut S2ClosestCellQuery,
        target: *mut S2ClosestCellQuery_Target,
        limit: S1ChordAngle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQuery33IsConservativeDistanceLessOrEqualEP16S2DistanceTargetI13S2MinDistanceE12S1ChordAngle"]
    pub fn S2ClosestCellQuery_IsConservativeDistanceLessOrEqual(
        this: *mut S2ClosestCellQuery,
        target: *mut S2ClosestCellQuery_Target,
        limit: S1ChordAngle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQueryC1EPK11S2CellIndexRKNS_7OptionsE"]
    pub fn S2ClosestCellQuery_S2ClosestCellQuery(
        this: *mut S2ClosestCellQuery,
        index: *const S2CellIndex,
        options: *const S2ClosestCellQuery_Options,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQueryC1Ev"]
    pub fn S2ClosestCellQuery_S2ClosestCellQuery1(this: *mut S2ClosestCellQuery);
}
extern "C" {
    #[link_name = "\u{1}_ZN18S2ClosestCellQueryD1Ev"]
    pub fn S2ClosestCellQuery_S2ClosestCellQuery_destructor(this: *mut S2ClosestCellQuery);
}
impl S2ClosestCellQuery {
    #[inline]
    pub unsafe fn Init(
        &mut self,
        index: *const S2CellIndex,
        options: *const S2ClosestCellQuery_Options,
    ) {
        S2ClosestCellQuery_Init(self, index, options)
    }
    #[inline]
    pub unsafe fn ReInit(&mut self) {
        S2ClosestCellQuery_ReInit(self)
    }
    #[inline]
    pub unsafe fn index(&self) -> *const S2CellIndex {
        S2ClosestCellQuery_index(self)
    }
    #[inline]
    pub unsafe fn options(&self) -> *const S2ClosestCellQuery_Options {
        S2ClosestCellQuery_options(self)
    }
    #[inline]
    pub unsafe fn mutable_options(&mut self) -> *mut S2ClosestCellQuery_Options {
        S2ClosestCellQuery_mutable_options(self)
    }
    #[inline]
    pub unsafe fn FindClosestCells(
        &mut self,
        target: *mut S2ClosestCellQuery_Target,
    ) -> [u64; 3usize] {
        S2ClosestCellQuery_FindClosestCells(self, target)
    }
    #[inline]
    pub unsafe fn FindClosestCells1(
        &mut self,
        target: *mut S2ClosestCellQuery_Target,
        results: *mut [u64; 3usize],
    ) {
        S2ClosestCellQuery_FindClosestCells1(self, target, results)
    }
    #[inline]
    pub unsafe fn FindClosestCell(
        &mut self,
        target: *mut S2ClosestCellQuery_Target,
    ) -> S2ClosestCellQuery_Result {
        S2ClosestCellQuery_FindClosestCell(self, target)
    }
    #[inline]
    pub unsafe fn GetDistance(&mut self, target: *mut S2ClosestCellQuery_Target) -> S1ChordAngle {
        S2ClosestCellQuery_GetDistance(self, target)
    }
    #[inline]
    pub unsafe fn IsDistanceLess(
        &mut self,
        target: *mut S2ClosestCellQuery_Target,
        limit: S1ChordAngle,
    ) -> bool {
        S2ClosestCellQuery_IsDistanceLess(self, target, limit)
    }
    #[inline]
    pub unsafe fn IsDistanceLessOrEqual(
        &mut self,
        target: *mut S2ClosestCellQuery_Target,
        limit: S1ChordAngle,
    ) -> bool {
        S2ClosestCellQuery_IsDistanceLessOrEqual(self, target, limit)
    }
    #[inline]
    pub unsafe fn IsConservativeDistanceLessOrEqual(
        &mut self,
        target: *mut S2ClosestCellQuery_Target,
        limit: S1ChordAngle,
    ) -> bool {
        S2ClosestCellQuery_IsConservativeDistanceLessOrEqual(self, target, limit)
    }
    #[inline]
    pub unsafe fn new(
        index: *const S2CellIndex,
        options: *const S2ClosestCellQuery_Options,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ClosestCellQuery_S2ClosestCellQuery(__bindgen_tmp.as_mut_ptr(), index, options);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2ClosestCellQuery_S2ClosestCellQuery1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        S2ClosestCellQuery_S2ClosestCellQuery_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK18S2ClosestCellQuery11PointTarget26max_brute_force_index_sizeEv"]
    pub fn S2ClosestCellQuery_PointTarget_max_brute_force_index_size(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18S2ClosestCellQuery10EdgeTarget26max_brute_force_index_sizeEv"]
    pub fn S2ClosestCellQuery_EdgeTarget_max_brute_force_index_size(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18S2ClosestCellQuery10CellTarget26max_brute_force_index_sizeEv"]
    pub fn S2ClosestCellQuery_CellTarget_max_brute_force_index_size(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18S2ClosestCellQuery15CellUnionTarget26max_brute_force_index_sizeEv"]
    pub fn S2ClosestCellQuery_CellUnionTarget_max_brute_force_index_size(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18S2ClosestCellQuery16ShapeIndexTarget26max_brute_force_index_sizeEv"]
    pub fn S2ClosestCellQuery_ShapeIndexTarget_max_brute_force_index_size(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct S2RegionTermIndexer {
    pub options_: S2RegionTermIndexer_Options,
    pub coverer_: S2RegionCoverer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2RegionTermIndexer_Options {
    pub _base: S2RegionCoverer_Options,
    pub points_only_: bool,
    pub optimize_for_space_: bool,
    pub marker_: std_string,
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer7Options20set_marker_characterEc"]
    pub fn S2RegionTermIndexer_Options_set_marker_character(
        this: *mut S2RegionTermIndexer_Options,
        ch: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer7OptionsC1Ev"]
    pub fn S2RegionTermIndexer_Options_Options(this: *mut S2RegionTermIndexer_Options);
}
impl S2RegionTermIndexer_Options {
    #[inline]
    pub unsafe fn set_marker_character(&mut self, ch: ::std::os::raw::c_char) {
        S2RegionTermIndexer_Options_set_marker_character(self, ch)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2RegionTermIndexer_Options_Options(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub const S2RegionTermIndexer_TermType_ANCESTOR: S2RegionTermIndexer_TermType = 0;
pub const S2RegionTermIndexer_TermType_COVERING: S2RegionTermIndexer_TermType = 1;
pub type S2RegionTermIndexer_TermType = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer13GetIndexTermsB5cxx11ERK8S2RegionSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2RegionTermIndexer_GetIndexTerms(
        this: *mut S2RegionTermIndexer,
        region: *const S2Region,
        prefix: absl_string_view,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer13GetQueryTermsB5cxx11ERK8S2RegionSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2RegionTermIndexer_GetQueryTerms(
        this: *mut S2RegionTermIndexer,
        region: *const S2Region,
        prefix: absl_string_view,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer13GetIndexTermsB5cxx11ERK7Vector3IdESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2RegionTermIndexer_GetIndexTerms1(
        this: *mut S2RegionTermIndexer,
        point: *const S2Point,
        prefix: absl_string_view,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer13GetQueryTermsB5cxx11ERK7Vector3IdESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2RegionTermIndexer_GetQueryTerms1(
        this: *mut S2RegionTermIndexer,
        point: *const S2Point,
        prefix: absl_string_view,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer33GetIndexTermsForCanonicalCoveringB5cxx11ERK11S2CellUnionSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2RegionTermIndexer_GetIndexTermsForCanonicalCovering(
        this: *mut S2RegionTermIndexer,
        covering: *const S2CellUnion,
        prefix: absl_string_view,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexer33GetQueryTermsForCanonicalCoveringB5cxx11ERK11S2CellUnionSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn S2RegionTermIndexer_GetQueryTermsForCanonicalCovering(
        this: *mut S2RegionTermIndexer,
        covering: *const S2CellUnion,
        prefix: absl_string_view,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexerC1Ev"]
    pub fn S2RegionTermIndexer_S2RegionTermIndexer(this: *mut S2RegionTermIndexer);
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexerC1ERKNS_7OptionsE"]
    pub fn S2RegionTermIndexer_S2RegionTermIndexer1(
        this: *mut S2RegionTermIndexer,
        options: *const S2RegionTermIndexer_Options,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexerC1EOS_"]
    pub fn S2RegionTermIndexer_S2RegionTermIndexer2(
        this: *mut S2RegionTermIndexer,
        arg1: *mut S2RegionTermIndexer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19S2RegionTermIndexerD1Ev"]
    pub fn S2RegionTermIndexer_S2RegionTermIndexer_destructor(this: *mut S2RegionTermIndexer);
}
impl S2RegionTermIndexer {
    #[inline]
    pub unsafe fn GetIndexTerms(
        &mut self,
        region: *const S2Region,
        prefix: absl_string_view,
    ) -> u8 {
        S2RegionTermIndexer_GetIndexTerms(self, region, prefix)
    }
    #[inline]
    pub unsafe fn GetQueryTerms(
        &mut self,
        region: *const S2Region,
        prefix: absl_string_view,
    ) -> u8 {
        S2RegionTermIndexer_GetQueryTerms(self, region, prefix)
    }
    #[inline]
    pub unsafe fn GetIndexTerms1(&mut self, point: *const S2Point, prefix: absl_string_view) -> u8 {
        S2RegionTermIndexer_GetIndexTerms1(self, point, prefix)
    }
    #[inline]
    pub unsafe fn GetQueryTerms1(&mut self, point: *const S2Point, prefix: absl_string_view) -> u8 {
        S2RegionTermIndexer_GetQueryTerms1(self, point, prefix)
    }
    #[inline]
    pub unsafe fn GetIndexTermsForCanonicalCovering(
        &mut self,
        covering: *const S2CellUnion,
        prefix: absl_string_view,
    ) -> u8 {
        S2RegionTermIndexer_GetIndexTermsForCanonicalCovering(self, covering, prefix)
    }
    #[inline]
    pub unsafe fn GetQueryTermsForCanonicalCovering(
        &mut self,
        covering: *const S2CellUnion,
        prefix: absl_string_view,
    ) -> u8 {
        S2RegionTermIndexer_GetQueryTermsForCanonicalCovering(self, covering, prefix)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2RegionTermIndexer_S2RegionTermIndexer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(options: *const S2RegionTermIndexer_Options) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2RegionTermIndexer_S2RegionTermIndexer1(__bindgen_tmp.as_mut_ptr(), options);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut S2RegionTermIndexer) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        S2RegionTermIndexer_S2RegionTermIndexer2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        S2RegionTermIndexer_S2RegionTermIndexer_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ctx {
    pub options: S2RegionTermIndexer_Options,
    pub indexer: S2RegionTermIndexer,
    pub documents: *mut u8,
    pub index: *mut u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN3ctx4loadEPKfm"]
    pub fn ctx_load(this: *mut ctx, _points: *const f32, len: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN3ctx6searchEfffPm"]
    pub fn ctx_search(
        this: *mut ctx,
        _lng: f32,
        _lat: f32,
        radius: f32,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN3ctx5clearEv"]
    pub fn ctx_clear(this: *mut ctx);
}
extern "C" {
    #[link_name = "\u{1}_ZN3ctxC1Ev"]
    pub fn ctx_ctx(this: *mut ctx);
}
impl ctx {
    #[inline]
    pub unsafe fn load(&mut self, _points: *const f32, len: usize) {
        ctx_load(self, _points, len)
    }
    #[inline]
    pub unsafe fn search(
        &mut self,
        _lng: f32,
        _lat: f32,
        radius: f32,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_void {
        ctx_search(self, _lng, _lat, radius, len)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        ctx_clear(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ctx_ctx(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub type ShapeVisitor = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Result {
    pub distance_: S2MinDistance,
    pub cell_id_: S2CellId,
    pub label_: S2ClosestCellQueryBase_Label,
}
pub type Result_absl_btree_prefer_linear_node_search = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Options {
    pub max_distance_: S2MinDistance,
    pub max_error_: Delta,
    pub region_: *const S2Region,
    pub max_results_: ::std::os::raw::c_int,
    pub use_brute_force_: bool,
}
pub const Options_kMaxMaxResults: ::std::os::raw::c_int = 2147483647;
extern "C" {
    #[link_name = "\u{1}_ZN22S2ClosestCellQueryBaseI13S2MinDistanceE7Options10set_regionEPK8S2Region"]
    pub fn Options_set_region(this: *mut Options, region: *const S2Region);
}
extern "C" {
    #[link_name = "\u{1}_ZN22S2ClosestCellQueryBaseI13S2MinDistanceE7Options19set_use_brute_forceEb"]
    pub fn Options_set_use_brute_force(this: *mut Options, use_brute_force: bool);
}
impl Options {
    #[inline]
    pub unsafe fn set_region(&mut self, region: *const S2Region) {
        Options_set_region(self, region)
    }
    #[inline]
    pub unsafe fn set_use_brute_force(&mut self, use_brute_force: bool) {
        Options_set_use_brute_force(self, use_brute_force)
    }
}
pub type Delta = S2MinDistance_Delta;
